import { __assign, __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import clsx from 'clsx';
import React, { useCallback, useRef, useState } from 'react';
import { getWeekStartByLocale } from 'weekstart';
import styles from './styles.css.js';
import Calendar from './calendar';
import { normalizeLocale } from './calendar/utils/locales';
import { getDateLabel } from './calendar/utils/intl';
import { displayToIso, formatDate, isoToDisplay, memoizedDate } from './calendar/utils/date';
import { KeyCode } from '../internal/keycode';
import { fireNonCancelableEvent } from '../internal/events';
import Dropdown from '../internal/components/dropdown';
import DateInput from '../internal/components/date-input';
import { getBaseProps } from '../internal/base-component';
import { applyDisplayName } from '../internal/utils/apply-display-name.js';
import checkControlled from '../internal/hooks/check-controlled';
import { useFocusTracker } from '../internal/hooks/use-focus-tracker.js';
import useForwardFocus from '../internal/hooks/forward-focus';
import { usePrevious } from '../internal/hooks/use-previous';
import { InternalButton } from '../button/internal';
import useBaseComponent from '../internal/hooks/use-base-component';
import { useUniqueId } from '../internal/hooks/use-unique-id';
import { useMergeRefs } from '../internal/hooks/use-merge-refs';
import TabTrap from '../internal/components/tab-trap';
var DatePicker = React.forwardRef(function (_a, ref) {
    var _b = _a.locale, locale = _b === void 0 ? '' : _b, startOfWeek = _a.startOfWeek, isDateEnabled = _a.isDateEnabled, nextMonthAriaLabel = _a.nextMonthAriaLabel, previousMonthAriaLabel = _a.previousMonthAriaLabel, todayAriaLabel = _a.todayAriaLabel, _c = _a.placeholder, placeholder = _c === void 0 ? '' : _c, _d = _a.value, value = _d === void 0 ? '' : _d, _e = _a.readOnly, readOnly = _e === void 0 ? false : _e, _f = _a.disabled, disabled = _f === void 0 ? false : _f, onBlur = _a.onBlur, _g = _a.autoFocus, autoFocus = _g === void 0 ? false : _g, onChange = _a.onChange, onFocus = _a.onFocus, name = _a.name, ariaLabel = _a.ariaLabel, ariaRequired = _a.ariaRequired, ariaLabelledby = _a.ariaLabelledby, ariaDescribedby = _a.ariaDescribedby, controlId = _a.controlId, invalid = _a.invalid, openCalendarAriaLabel = _a.openCalendarAriaLabel, expandToViewport = _a.expandToViewport, rest = __rest(_a, ["locale", "startOfWeek", "isDateEnabled", "nextMonthAriaLabel", "previousMonthAriaLabel", "todayAriaLabel", "placeholder", "value", "readOnly", "disabled", "onBlur", "autoFocus", "onChange", "onFocus", "name", "ariaLabel", "ariaRequired", "ariaLabelledby", "ariaDescribedby", "controlId", "invalid", "openCalendarAriaLabel", "expandToViewport"]);
    var __internalRootRef = useBaseComponent('DatePicker').__internalRootRef;
    var baseProps = getBaseProps(rest);
    var _h = useState(false), isDropDownOpen = _h[0], setIsDropDownOpen = _h[1];
    var _j = useState(false), calendarHasFocus = _j[0], setCalendarHasFocus = _j[1];
    var normalizedLocale = normalizeLocale('DatePicker', locale !== null && locale !== void 0 ? locale : '');
    var normalizedStartOfWeek = (typeof startOfWeek === 'number' ? startOfWeek : getWeekStartByLocale(normalizedLocale));
    var defaultSelectedDate = value.length >= 10 ? value : null;
    var _k = useState(defaultSelectedDate), selectedDate = _k[0], setSelectedDate = _k[1];
    var defaultDisplayedDate = value.length >= 10 ? value : formatDate(new Date());
    var _l = useState(defaultDisplayedDate), displayedDate = _l[0], setDisplayedDate = _l[1];
    var _m = useState(null), focusedDate = _m[0], setFocusedDate = _m[1];
    var internalInputRef = useRef(null);
    var buttonRef = useRef(null);
    var calendarRef = useRef(null);
    useForwardFocus(ref, internalInputRef);
    var rootRef = useRef(null);
    var dropdownId = useUniqueId('calender');
    var mergedRef = useMergeRefs(rootRef, __internalRootRef);
    useFocusTracker({ rootRef: rootRef, onBlur: onBlur, onFocus: onFocus, viewportId: expandToViewport ? dropdownId : '' });
    var onChangeMonthHandler = function (newMonth) {
        setDisplayedDate(formatDate(newMonth));
        setFocusedDate(null);
    };
    var onSelectDateHandler = function (_a) {
        var _b;
        var date = _a.date;
        var formattedDate = formatDate(date);
        (_b = buttonRef.current) === null || _b === void 0 ? void 0 : _b.focus();
        setIsDropDownOpen(false);
        setSelectedDate(formattedDate);
        setDisplayedDate(formattedDate);
        setCalendarHasFocus(false);
        setFocusedDate(null);
        fireNonCancelableEvent(onChange, { value: formattedDate });
    };
    var onDateFocusHandler = function (_a) {
        var date = _a.date;
        if (date) {
            var value_1 = formatDate(date);
            setFocusedDate(value_1);
        }
    };
    var onDropdownCloseHandler = useCallback(function () {
        setDisplayedDate(defaultDisplayedDate);
        setCalendarHasFocus(false);
        setIsDropDownOpen(false);
    }, [defaultDisplayedDate]);
    var onButtonClickHandler = function () {
        if (!isDropDownOpen) {
            setIsDropDownOpen(true);
            setCalendarHasFocus(true);
        }
    };
    var onWrapperKeyDownHandler = function (event) {
        var _a;
        if (event.keyCode === KeyCode.escape && isDropDownOpen) {
            (_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            setIsDropDownOpen(false);
        }
    };
    var onInputChangeHandler = function (event) {
        var isoDateString = displayToIso(event.detail.value);
        fireNonCancelableEvent(onChange, { value: isoDateString });
    };
    var onInputBlurHandler = function () {
        if (!calendarHasFocus) {
            setDisplayedDate(defaultDisplayedDate);
            setIsDropDownOpen(false);
        }
    };
    var prevValue = usePrevious(value);
    if (prevValue !== value) {
        if (value === '' && selectedDate !== value) {
            setSelectedDate(value);
        }
        // update the displayedDate when inputValue changes in order to
        // display the correct month when the date picker gets open again.
        if (value.length >= 4 && displayedDate !== value) {
            setDisplayedDate(value);
        }
        // set the selected date only when a full date (yyyy-mm-dd) is entered
        if (value.length >= 10 && selectedDate !== value) {
            setSelectedDate(value);
        }
    }
    var focusCurrentDate = function () { var _a, _b; return (_b = (_a = calendarRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(".".concat(styles['calendar-day-focusable']))) === null || _b === void 0 ? void 0 : _b.focus(); };
    var DateInputElement = (React.createElement("div", { className: styles['date-picker-trigger'] },
        React.createElement("div", { className: styles['date-picker-input'] },
            React.createElement(DateInput, { name: name, invalid: invalid, controlId: controlId, ariaLabelledby: ariaLabelledby, ariaDescribedby: ariaDescribedby, ariaLabel: ariaLabel, ariaRequired: ariaRequired, value: isoToDisplay(value), autoComplete: false, disableBrowserAutocorrect: true, disableAutocompleteOnBlur: calendarHasFocus, disabled: disabled, readOnly: readOnly, onChange: onInputChangeHandler, onBlur: onInputBlurHandler, placeholder: placeholder, ref: internalInputRef, autoFocus: autoFocus })),
        React.createElement("div", null,
            React.createElement(InternalButton, { iconName: "calendar", className: styles['open-calendar-button'], onClick: onButtonClickHandler, ref: buttonRef, ariaLabel: openCalendarAriaLabel &&
                    openCalendarAriaLabel(value.length === 10 ? getDateLabel(normalizedLocale, memoizedDate('value', value)) : null), disabled: disabled || readOnly, formAction: "none" }))));
    baseProps.className = clsx(baseProps.className, styles.root, styles['date-picker-container']);
    if (readOnly || disabled) {
        return React.createElement("div", __assign({}, baseProps), DateInputElement);
    }
    checkControlled('DatePicker', 'value', value, 'onChange', onChange);
    var handleMouseDown = function (event) {
        // prevent currently focused element from losing it
        event.preventDefault();
    };
    return (React.createElement("div", __assign({}, baseProps, { ref: mergedRef, onKeyDown: onWrapperKeyDownHandler }),
        React.createElement(Dropdown, { stretchWidth: true, stretchHeight: true, open: isDropDownOpen, onDropdownClose: onDropdownCloseHandler, onMouseDown: handleMouseDown, trigger: DateInputElement, expandToViewport: expandToViewport, scrollable: false, dropdownId: dropdownId }, isDropDownOpen && (React.createElement(React.Fragment, null,
            calendarHasFocus && React.createElement(TabTrap, { focusNextCallback: focusCurrentDate }),
            React.createElement(Calendar, { ref: calendarRef, selectedDate: memoizedDate('value', selectedDate), focusedDate: memoizedDate('focused', focusedDate), displayedDate: memoizedDate('displayed', displayedDate), locale: normalizedLocale, startOfWeek: normalizedStartOfWeek, isDateEnabled: isDateEnabled ? isDateEnabled : function () { return true; }, calendarHasFocus: calendarHasFocus, nextMonthLabel: nextMonthAriaLabel, previousMonthLabel: previousMonthAriaLabel, todayAriaLabel: todayAriaLabel, onChangeMonth: onChangeMonthHandler, onSelectDate: onSelectDateHandler, onFocusDate: onDateFocusHandler }),
            calendarHasFocus && React.createElement(TabTrap, { focusNextCallback: function () { var _a; return (_a = calendarRef.current) === null || _a === void 0 ? void 0 : _a.focus(); } }))))));
});
applyDisplayName(DatePicker, 'DatePicker');
export default DatePicker;
//# sourceMappingURL=index.js.map