{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { forwardRef, useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport focusSvgElement from '../../utils/focus-svg-element';\nimport styles from './styles.css.js';\nexport default forwardRef(ApplicationController);\n\nfunction ApplicationController(_a, ref) {\n  var activeElementKey = _a.activeElementKey,\n      activeElementRef = _a.activeElementRef,\n      onFocus = _a.onFocus,\n      onBlur = _a.onBlur,\n      onKeyDown = _a.onKeyDown;\n  var containerRef = useRef(null);\n  var applicationRef = useRef(null);\n  var focusTransitionRef = useRef(false);\n\n  var _b = useState(false),\n      isFocused = _b[0],\n      setFocused = _b[1]; // Calls provided onFocus handler when the application obtains focus, ignoring internal focus juggling.\n\n\n  var onApplicationFocus = useCallback(function (event) {\n    if (focusTransitionRef.current === false) {\n      setFocused(true);\n      onFocus && onFocus(event);\n    } else {\n      focusTransitionRef.current = false;\n    }\n  }, [onFocus]); // Calls provided onBlur handler when the application loses focus, ignoring internal focus juggling.\n\n  var onApplicationBlur = useCallback(function (event) {\n    if (focusTransitionRef.current === false) {\n      setFocused(false);\n      onBlur && onBlur(event); // The application controller can only be focused programmatically.\n\n      muteApplication(applicationRef.current);\n    }\n  }, [onBlur]);\n  var onApplicationKeyDown = onKeyDown;\n  useImperativeHandle(ref, function () {\n    return {\n      focus: function focus() {\n        return focusApplication(applicationRef.current, (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || null);\n      }\n    };\n  }, [activeElementRef]); // Re-attaches and re-focuses the application for screen readers to treat it as an update.\n\n  useEffect(function () {\n    // Skip if not focused or if the transition is already happening.\n    if (!isFocused || focusTransitionRef.current === true) {\n      return;\n    } // Delay focus juggle to let the last focus event settle in Firefox.\n    // Without the delay the focus is getting lost.\n\n\n    var timeoutId = setTimeout(function () {\n      focusTransitionRef.current = true;\n      containerRef.current.removeChild(applicationRef.current);\n      containerRef.current.appendChild(applicationRef.current);\n      focusApplication(applicationRef.current, (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || null);\n    }, 0);\n    return function () {\n      return clearTimeout(timeoutId);\n    };\n  }, [isFocused, activeElementKey, activeElementRef]);\n  return React.createElement(\"g\", {\n    ref: containerRef\n  }, React.createElement(\"g\", {\n    focusable: false,\n    tabIndex: -1,\n    ref: applicationRef,\n    onFocus: onApplicationFocus,\n    onBlur: onApplicationBlur,\n    onKeyDown: onApplicationKeyDown,\n    className: styles.application\n  }));\n} // Focuses application but before copies aria-attributes from the target.\n\n\nfunction focusApplication(app, target) {\n  // Remove prev attributes.\n  for (var _i = 0, _a = getAttributeNames(app); _i < _a.length; _i++) {\n    var attributeName = _a[_i];\n\n    if (attributeName === 'role' || attributeName.slice(0, 4) === 'aria') {\n      app.removeAttribute(attributeName);\n    }\n  } // Copy new attributes.\n\n\n  if (target) {\n    for (var _b = 0, _c = getAttributeNames(target); _b < _c.length; _b++) {\n      var attributeName = _c[_b];\n\n      if (attributeName === 'role' || attributeName.slice(0, 4) === 'aria') {\n        var attributeValue = target.getAttribute(attributeName);\n        attributeValue && app.setAttribute(attributeName, attributeValue);\n      }\n    }\n  } // Make app focusable.\n\n\n  app.tabIndex = 0;\n  app.setAttribute('focusable', 'true');\n  app.setAttribute('aria-hidden', 'false'); // Focus app.\n\n  focusSvgElement(app);\n} // The application is to be only focused programmatically.\n\n\nfunction muteApplication(app) {\n  // Remove prev attributes.\n  for (var _i = 0, _a = getAttributeNames(app); _i < _a.length; _i++) {\n    var attributeName = _a[_i];\n\n    if (attributeName === 'role' || attributeName.slice(0, 4) === 'aria') {\n      app.removeAttribute(attributeName);\n    }\n  } // Make app non-focusable.\n\n\n  app.tabIndex = -1;\n  app.setAttribute('focusable', 'false');\n  app.setAttribute('aria-hidden', 'true');\n} // Polyfill for element.getAttributeNames(), IE11\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames#polyfill\n\n\nfunction getAttributeNames(element) {\n  var attributes = element.attributes;\n  var result = new Array(attributes.length);\n\n  for (var i = 0; i < attributes.length; i++) {\n    result[i] = attributes[i].name;\n  }\n\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}