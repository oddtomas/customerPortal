{"ast":null,"code":"import { __assign, __rest } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { getBaseProps } from '../internal/base-component';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport InternalBox from '../box/internal';\nimport ChartStatusContainer, { getChartStatus } from '../internal/components/chart-status-container';\nimport { useControllable } from '../internal/hooks/use-controllable';\nimport { usePrevious } from '../internal/hooks/use-previous';\nimport { warnOnce } from '../internal/logging';\nimport InternalChartFilters from './chart-filters';\nimport InternalChartLegend from './chart-legend';\nimport ChartContainer from './chart-container';\nimport cartesianStyles from '../internal/components/cartesian-chart/styles.css.js';\nimport styles from './styles.css.js';\nimport { isDevelopment } from '../internal/is-development';\nimport createCategoryColorScale from '../internal/utils/create-category-color-scale';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { nodeContains } from '../internal/utils/dom';\nexport default function InternalMixedLineBarChart(_a) {\n  var _b;\n\n  var height = _a.height,\n      xScaleType = _a.xScaleType,\n      yScaleType = _a.yScaleType,\n      xDomain = _a.xDomain,\n      yDomain = _a.yDomain,\n      controlledHighlightedSeries = _a.highlightedSeries,\n      controlledVisibleSeries = _a.visibleSeries,\n      externalSeries = _a.series,\n      onFilterChange = _a.onFilterChange,\n      controlledOnHighlightChange = _a.onHighlightChange,\n      i18nStrings = _a.i18nStrings,\n      ariaLabel = _a.ariaLabel,\n      ariaLabelledby = _a.ariaLabelledby,\n      ariaDescription = _a.ariaDescription,\n      xTitle = _a.xTitle,\n      yTitle = _a.yTitle,\n      stackedBars = _a.stackedBars,\n      horizontalBars = _a.horizontalBars,\n      hideFilter = _a.hideFilter,\n      additionalFilters = _a.additionalFilters,\n      hideLegend = _a.hideLegend,\n      legendTitle = _a.legendTitle,\n      statusType = _a.statusType,\n      detailPopoverSize = _a.detailPopoverSize,\n      emphasizeBaselineAxis = _a.emphasizeBaselineAxis,\n      empty = _a.empty,\n      noMatch = _a.noMatch,\n      errorText = _a.errorText,\n      loadingText = _a.loadingText,\n      recoveryText = _a.recoveryText,\n      onRecoveryClick = _a.onRecoveryClick,\n      _c = _a.__internalRootRef,\n      __internalRootRef = _c === void 0 ? null : _c,\n      props = __rest(_a, [\"height\", \"xScaleType\", \"yScaleType\", \"xDomain\", \"yDomain\", \"highlightedSeries\", \"visibleSeries\", \"series\", \"onFilterChange\", \"onHighlightChange\", \"i18nStrings\", \"ariaLabel\", \"ariaLabelledby\", \"ariaDescription\", \"xTitle\", \"yTitle\", \"stackedBars\", \"horizontalBars\", \"hideFilter\", \"additionalFilters\", \"hideLegend\", \"legendTitle\", \"statusType\", \"detailPopoverSize\", \"emphasizeBaselineAxis\", \"empty\", \"noMatch\", \"errorText\", \"loadingText\", \"recoveryText\", \"onRecoveryClick\", \"__internalRootRef\"]);\n\n  var baseProps = getBaseProps(props);\n  var containerRef = useRef(null);\n  useEffect(function () {\n    var gotBarSeries = externalSeries.some(function (s) {\n      return s.type === 'bar';\n    });\n    var gotLineSeries = externalSeries.some(function (s) {\n      return s.type === 'line';\n    });\n\n    if (xScaleType !== 'categorical' && gotBarSeries) {\n      warnOnce('MixedLineBarChart', \"Bar series cannot be used with a \".concat(xScaleType, \" scale. Use a categorical x axis instead.\"));\n    }\n\n    if (horizontalBars && gotLineSeries) {\n      warnOnce('MixedLineBarChart', \"Property horizontalBars can only be used with charts that contain only bar or threshold series.\");\n    }\n  }, [xScaleType, horizontalBars, externalSeries]);\n  var series = useMemo(function () {\n    var colors = createCategoryColorScale(externalSeries, function (it) {\n      return it.type === 'threshold';\n    }, function (it) {\n      return it.color || null;\n    });\n    return externalSeries.map(function (s, i) {\n      return {\n        index: i,\n        color: colors[i],\n        series: s\n      };\n    });\n  }, [externalSeries]);\n\n  var _d = useState(null),\n      highlightedPoint = _d[0],\n      setHighlightedPoint = _d[1];\n\n  var _e = useState(null),\n      highlightedGroupIndex = _e[0],\n      setHighlightedGroupIndex = _e[1];\n\n  var _f = useControllable(controlledHighlightedSeries, controlledOnHighlightChange, null, {\n    componentName: 'MixedLineBarChart',\n    controlledProp: 'highlightedSeries',\n    changeHandler: 'onHighlightChange'\n  }),\n      _g = _f[0],\n      highlightedSeries = _g === void 0 ? null : _g,\n      setHighlightedSeries = _f[1];\n\n  var _h = useState(highlightedSeries),\n      legendSeries = _h[0],\n      setLegendSeries = _h[1];\n\n  useEffect(function () {\n    setLegendSeries(controlledHighlightedSeries || null);\n  }, [controlledHighlightedSeries]);\n\n  var _j = useControllable(controlledVisibleSeries, onFilterChange, externalSeries, {\n    componentName: 'MixedLineBarChart',\n    controlledProp: 'visibleSeries',\n    changeHandler: 'onFilterChange'\n  }),\n      externalVisibleSeries = _j[0],\n      setExternalVisibleSeries = _j[1];\n\n  if (isDevelopment) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    var previousSeries = usePrevious(externalSeries);\n    var hasPrevious = !!(previousSeries && previousSeries.length);\n    var hasCurrent = !!externalSeries.length;\n\n    if (hasPrevious && hasCurrent && externalSeries !== previousSeries && !controlledVisibleSeries && !hideFilter) {\n      warnOnce('MixedLineBarChart', 'The `series` value passed into the component changed. ' + 'This may cause problems with filtering - we recommend that you make the `series` value constant, ' + 'or provide a `visibleSeries` value that derives from the current `series` value.');\n    }\n  }\n\n  var visibleSeries = useMemo(function () {\n    return series.filter(function (s) {\n      return (externalVisibleSeries === null || externalVisibleSeries === void 0 ? void 0 : externalVisibleSeries.indexOf(s.series)) !== -1;\n    });\n  }, [series, externalVisibleSeries]);\n\n  var filterChange = function filterChange(selectedSeries) {\n    setExternalVisibleSeries(selectedSeries);\n    fireNonCancelableEvent(onFilterChange, {\n      visibleSeries: selectedSeries\n    });\n  };\n\n  var onHighlightChange = function onHighlightChange(series) {\n    setHighlightedSeries(series);\n    fireNonCancelableEvent(controlledOnHighlightChange, {\n      highlightedSeries: series\n    });\n    setLegendSeries(series);\n  };\n\n  var onBlur = function onBlur(event) {\n    if (event.relatedTarget && !nodeContains(containerRef.current, event.relatedTarget)) {\n      highlightedSeries && onHighlightChange(highlightedSeries);\n      setHighlightedPoint(null);\n      setHighlightedGroupIndex(null);\n      setLegendSeries(null);\n    }\n  };\n\n  var _k = getChartStatus({\n    externalData: externalSeries,\n    visibleData: visibleSeries || [],\n    statusType: statusType\n  }),\n      isEmpty = _k.isEmpty,\n      isNoMatch = _k.isNoMatch,\n      showChart = _k.showChart;\n\n  var showFilters = statusType === 'finished' && (!isEmpty || isNoMatch);\n  var showLegend = !hideLegend && !isEmpty && statusType === 'finished';\n  var reserveLegendSpace = !showChart && !hideLegend;\n  var reserveFilterSpace = !showChart && !isNoMatch && (!hideFilter || additionalFilters);\n  var mergedRef = useMergeRefs(containerRef, __internalRootRef);\n  return React.createElement(\"div\", __assign({}, baseProps, {\n    className: clsx(baseProps.className, styles.root),\n    ref: mergedRef,\n    onBlur: onBlur\n  }), showFilters && React.createElement(InternalBox, {\n    className: cartesianStyles['filter-container'],\n    margin: {\n      bottom: 'l'\n    }\n  }, React.createElement(InternalChartFilters, {\n    series: series,\n    visibleSeries: externalVisibleSeries || [],\n    onChange: filterChange,\n    i18nStrings: i18nStrings,\n    hideFilter: hideFilter,\n    additionalFilters: additionalFilters\n  })), React.createElement(\"div\", {\n    className: clsx(styles.content, (_b = {}, _b[styles['content--reserve-filter']] = reserveFilterSpace, _b[styles['content--reserve-legend']] = reserveLegendSpace, _b)),\n    style: {\n      minHeight: height\n    }\n  }, React.createElement(ChartStatusContainer, {\n    isEmpty: isEmpty,\n    isNoMatch: isNoMatch,\n    showChart: showChart,\n    statusType: statusType,\n    empty: empty,\n    noMatch: noMatch,\n    loadingText: loadingText,\n    errorText: errorText,\n    recoveryText: recoveryText,\n    onRecoveryClick: onRecoveryClick\n  }), showChart && React.createElement(ChartContainer, {\n    height: height,\n    xScaleType: xScaleType,\n    yScaleType: yScaleType,\n    xDomain: xDomain,\n    yDomain: yDomain,\n    xTickFormatter: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.xTickFormatter,\n    yTickFormatter: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.yTickFormatter,\n    emphasizeBaselineAxis: emphasizeBaselineAxis,\n    stackedBars: stackedBars,\n    horizontalBars: horizontalBars,\n    series: series,\n    visibleSeries: visibleSeries,\n    highlightedSeries: highlightedSeries,\n    onHighlightChange: onHighlightChange,\n    highlightedPoint: highlightedPoint,\n    setHighlightedPoint: setHighlightedPoint,\n    highlightedGroupIndex: highlightedGroupIndex,\n    setHighlightedGroupIndex: setHighlightedGroupIndex,\n    legendSeries: legendSeries,\n    detailPopoverSize: detailPopoverSize,\n    xTitle: xTitle,\n    yTitle: yTitle,\n    ariaLabel: ariaLabel,\n    ariaLabelledby: ariaLabelledby,\n    ariaDescription: ariaDescription,\n    i18nStrings: i18nStrings,\n    plotContainerRef: containerRef\n  })), showLegend && React.createElement(InternalBox, {\n    margin: {\n      top: 'm'\n    }\n  }, React.createElement(InternalChartLegend, {\n    series: series,\n    visibleSeries: externalVisibleSeries || [],\n    highlightedSeries: legendSeries,\n    onHighlightChange: onHighlightChange,\n    legendTitle: legendTitle,\n    ariaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.legendAriaLabel,\n    plotContainerRef: containerRef\n  })));\n}","map":null,"metadata":{},"sourceType":"module"}