{"ast":null,"code":"var BREAKPOINT_MAPPING = [['xl', 1840], ['l', 1320], ['m', 1120], ['s', 912], ['xs', 688], ['xxs', 465], ['default', -1]];\nexport var mobileBreakpoint = BREAKPOINT_MAPPING.filter(function (b) {\n  return b[0] === 'xs';\n})[0][1];\nvar BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(function (_a) {\n  var bp = _a[0];\n  return bp;\n});\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\n\nexport function matchBreakpointMapping(subset, actual) {\n  var qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n\n  for (var _i = 0, qualifyingBreakpoints_1 = qualifyingBreakpoints; _i < qualifyingBreakpoints_1.length; _i++) {\n    var breakpoint = qualifyingBreakpoints_1[_i][0];\n    var breakpointValue = subset[breakpoint];\n\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n\n  return null;\n}\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\n\nexport function getMatchingBreakpoint(width, breakpointFilter) {\n  for (var _i = 0, BREAKPOINT_MAPPING_1 = BREAKPOINT_MAPPING; _i < BREAKPOINT_MAPPING_1.length; _i++) {\n    var _a = BREAKPOINT_MAPPING_1[_i],\n        breakpoint = _a[0],\n        breakpointWidth = _a[1];\n\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n\n  return 'default';\n}","map":null,"metadata":{},"sourceType":"module"}