{"ast":null,"code":"import { __assign } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { getContainingBlock, nodeContains } from '../internal/utils/dom';\nimport { useContainerQuery } from '../internal/hooks/container-queries';\nimport { calculatePosition } from './utils/positions';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nvar INITIAL_STYLES = {\n  position: 'absolute',\n  top: -9999,\n  left: -9999\n};\nexport default function PopoverContainer(_a) {\n  var position = _a.position,\n      trackRef = _a.trackRef,\n      trackKey = _a.trackKey,\n      arrow = _a.arrow,\n      children = _a.children,\n      zIndex = _a.zIndex,\n      renderWithPortal = _a.renderWithPortal;\n\n  var _b = useContainerQuery(function (rect, prev) {\n    var roundedRect = {\n      width: Math.round(rect.width),\n      height: Math.round(rect.height)\n    };\n    return (prev === null || prev === void 0 ? void 0 : prev.width) === roundedRect.width && (prev === null || prev === void 0 ? void 0 : prev.height) === roundedRect.height ? prev : rect;\n  }),\n      popoverRect = _b[0],\n      ref = _b[1];\n\n  var bodyRef = useRef(null);\n  var arrowRef = useRef(null);\n\n  var _c = useState(INITIAL_STYLES),\n      inlineStyle = _c[0],\n      setInlineStyle = _c[1];\n\n  var _d = useState(null),\n      internalPosition = _d[0],\n      setInternalPosition = _d[1];\n\n  var isRefresh = useVisualRefresh(ref); // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n\n  var positionHandlerRef = useRef(function () {}); // Updates the position handler.\n\n  var updatePositionHandler = useCallback(function () {\n    if (!trackRef.current || !ref.current || !bodyRef.current || !arrowRef.current) {\n      return;\n    } // Get important elements\n\n\n    var body = bodyRef.current;\n    var arrow = arrowRef.current;\n    var document = ref.current.ownerDocument;\n    var track = trackRef.current; // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n\n    if (body.offsetWidth === 0 || body.offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    } // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n\n\n    var prevTop = body.style.top;\n    var prevLeft = body.style.left;\n    body.style.top = '0';\n    body.style.left = '0'; // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n\n    var viewportRect = getViewportRect(document.defaultView);\n    var trackRect = track.getBoundingClientRect();\n    var arrowRect = {\n      width: parseFloat(getComputedStyle(arrow).width),\n      height: parseFloat(getComputedStyle(arrow).height)\n    };\n    var containingBlock = getContainingBlock(body);\n    var containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect; // Round up dimensions (IE11 doesn't handle subpixels too accurately)\n\n    var bodyRect = body.getBoundingClientRect();\n    var bodyRectCeil = {\n      top: bodyRect.top,\n      left: bodyRect.left,\n      width: Math.ceil(bodyRect.width),\n      height: Math.ceil(bodyRect.height)\n    }; // Calculate the arrow direction and viewport-relative position of the popover.\n\n    var _a = calculatePosition(position, trackRect, arrowRect, bodyRectCeil, containingBlock ? containingBlockRect : getDocumentRect(document), viewportRect, renderWithPortal),\n        newInternalPosition = _a.internalPosition,\n        boundingOffset = _a.boundingOffset; // Get the position of the popover relative to the offset parent.\n\n\n    var popoverOffset = toRelativePosition(boundingOffset, containingBlockRect); // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n\n    var trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect)); // Bring back the container to its original position to prevent any\n    // flashing.\n\n    body.style.top = prevTop;\n    body.style.left = prevLeft; // Position the popover\n\n    setInternalPosition(newInternalPosition);\n    setInlineStyle({\n      top: popoverOffset.top,\n      left: popoverOffset.left\n    });\n\n    positionHandlerRef.current = function () {\n      var newTrackOffset = toRelativePosition(track.getBoundingClientRect(), containingBlock ? containingBlock.getBoundingClientRect() : viewportRect);\n      setInlineStyle({\n        top: newTrackOffset.top + trackRelativeOffset.top,\n        left: newTrackOffset.left + trackRelativeOffset.left\n      });\n    };\n  }, [position, trackRef, ref, renderWithPortal]); // Update the handler when properties change.\n\n  useLayoutEffect(function () {\n    updatePositionHandler();\n  }, [updatePositionHandler, trackKey, popoverRect]); // Attach document listeners.\n\n  useLayoutEffect(function () {\n    /*\n      This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),\n      and by tracking the click event we can adapt the popover's position to the new layout.\n           TODO: extend this to Enter and Spacebar?\n    */\n    var updatePosition = function updatePosition() {\n      return requestAnimationFrame(function () {\n        return updatePositionHandler();\n      });\n    };\n\n    var refreshPosition = function refreshPosition() {\n      return requestAnimationFrame(function () {\n        return positionHandlerRef.current();\n      });\n    };\n\n    window.addEventListener('click', updatePosition);\n    window.addEventListener('resize', updatePosition);\n    window.addEventListener('scroll', refreshPosition, true);\n    return function () {\n      window.removeEventListener('click', updatePosition);\n      window.removeEventListener('resize', updatePosition);\n      window.removeEventListener('scroll', refreshPosition, true);\n    };\n  }, [updatePositionHandler]);\n  var mergedRef = useMergeRefs(bodyRef, ref);\n  return React.createElement(\"div\", {\n    ref: mergedRef,\n    style: __assign(__assign({}, inlineStyle), {\n      zIndex: zIndex\n    }),\n    className: clsx(styles.container, isRefresh && styles.refresh)\n  }, React.createElement(\"div\", {\n    ref: arrowRef,\n    className: clsx(styles[\"container-arrow\"], styles[\"container-arrow-position-\".concat(internalPosition)]),\n    \"aria-hidden\": true\n  }, arrow(internalPosition)), children);\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\n\nfunction toRelativePosition(element, parent) {\n  return {\n    top: element.top - parent.top,\n    left: element.left - parent.left\n  };\n}\n/**\n * Get a BoundingOffset that represents the visible viewport.\n */\n\n\nfunction getViewportRect(window) {\n  return {\n    top: 0,\n    left: 0,\n    width: window.innerWidth,\n    height: window.innerHeight\n  };\n}\n\nfunction getDocumentRect(document) {\n  var _a = document.documentElement.getBoundingClientRect(),\n      top = _a.top,\n      left = _a.left;\n\n  return {\n    top: top,\n    left: left,\n    width: document.documentElement.scrollWidth,\n    height: document.documentElement.scrollHeight\n  };\n}","map":null,"metadata":{},"sourceType":"module"}