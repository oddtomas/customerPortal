{"ast":null,"code":"var CustomEventStub =\n/** @class */\nfunction () {\n  function CustomEventStub(cancelable, detail) {\n    if (cancelable === void 0) {\n      cancelable = false;\n    }\n\n    if (detail === void 0) {\n      detail = null;\n    }\n\n    this.cancelable = cancelable;\n    this.detail = detail;\n    this.defaultPrevented = false;\n    this.cancelBubble = false;\n  }\n\n  CustomEventStub.prototype.preventDefault = function () {\n    this.defaultPrevented = true;\n  };\n\n  CustomEventStub.prototype.stopPropagation = function () {\n    this.cancelBubble = true;\n  };\n\n  return CustomEventStub;\n}();\n\nexport function createCustomEvent(_a) {\n  var cancelable = _a.cancelable,\n      detail = _a.detail;\n  return new CustomEventStub(cancelable, detail);\n}\nexport function fireNonCancelableEvent(handler, detail) {\n  if (!handler) {\n    return;\n  }\n\n  var event = createCustomEvent({\n    cancelable: false,\n    detail: detail\n  });\n  handler(event);\n}\nexport function fireCancelableEvent(handler, detail, sourceEvent) {\n  if (!handler) {\n    return false;\n  }\n\n  var event = createCustomEvent({\n    cancelable: true,\n    detail: detail\n  });\n  handler(event);\n\n  if (event.defaultPrevented && sourceEvent) {\n    sourceEvent.preventDefault();\n  }\n\n  if (event.cancelBubble && sourceEvent) {\n    sourceEvent.stopPropagation();\n  }\n\n  return event.defaultPrevented;\n}\nexport function fireKeyboardEvent(handler, reactEvent) {\n  return fireCancelableEvent(handler, {\n    keyCode: reactEvent.keyCode,\n    key: reactEvent.key,\n    ctrlKey: reactEvent.ctrlKey,\n    shiftKey: reactEvent.shiftKey,\n    altKey: reactEvent.altKey,\n    metaKey: reactEvent.metaKey\n  }, reactEvent);\n}\n\nvar isMouseEvent = function isMouseEvent(e) {\n  return e.button !== undefined;\n};\n\nexport function isPlainLeftClick(event) {\n  return event && (!isMouseEvent(event) || event.button === 0) && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey;\n}\n/**\n * Returns the element the focus is going to, when a blur event is fired.\n * IE11 does not support `realtedTarget` on blur FocusEvent's. However, it\n * moves the focus before the blur event is fired, so we can get the needed\n * element by accessing `document.activeElement`\n * @param event FocusEvent - native focus event\n * @returns Node | null - the element recieving the focus\n */\n\nexport var getBlurEventRelatedTarget = function getBlurEventRelatedTarget(event) {\n  return event.relatedTarget || document.activeElement;\n};","map":null,"metadata":{},"sourceType":"module"}