{"ast":null,"code":"export var getOverflowParents = function getOverflowParents(element) {\n  var parents = [];\n  var node = element;\n\n  while ((node = node.parentElement) && node !== document.body) {\n    getComputedStyle(node).overflow !== 'visible' && parents.push(node);\n  }\n\n  return parents;\n};\nexport var getOverflowParentDimensions = function getOverflowParentDimensions(element, excludeClosestParent, expandToViewport, canExpandOutsideViewport) {\n  if (excludeClosestParent === void 0) {\n    excludeClosestParent = false;\n  }\n\n  if (expandToViewport === void 0) {\n    expandToViewport = false;\n  }\n\n  if (canExpandOutsideViewport === void 0) {\n    canExpandOutsideViewport = false;\n  }\n\n  var parents = expandToViewport ? [] : getOverflowParents(element).map(function (el) {\n    var _a = el.getBoundingClientRect(),\n        height = _a.height,\n        width = _a.width,\n        top = _a.top,\n        left = _a.left;\n\n    return {\n      // Treat the whole scrollable area as the available height\n      // if we're allowed to expand past the viewport.\n      height: canExpandOutsideViewport ? el.scrollHeight : height,\n      width: width,\n      top: top,\n      left: left\n    };\n  });\n\n  if (canExpandOutsideViewport && !expandToViewport) {\n    var documentDimensions = document.documentElement.getBoundingClientRect();\n    parents.push({\n      width: Math.max(documentDimensions.width, document.documentElement.clientWidth),\n      height: Math.max(documentDimensions.height, document.documentElement.clientHeight),\n      top: documentDimensions.top,\n      left: documentDimensions.left\n    });\n  } else {\n    parents.push({\n      height: window.innerHeight,\n      width: window.innerWidth,\n      top: 0,\n      left: 0\n    });\n  }\n\n  if (excludeClosestParent && !expandToViewport) {\n    parents.shift();\n  }\n\n  return parents;\n};\n/**\n * If the element is out of view, scrolls the scroll parent until\n * the element is visible.\n *\n * Basically an IE11/Safari polyfill for `elem.scrollIntoView({ block: 'nearest' })`\n */\n\nexport function scrollUntilVisible(element) {\n  var _a;\n\n  var parent = (_a = element.offsetParent) !== null && _a !== void 0 ? _a : document.documentElement; // Anchor to top of scroll parent.\n\n  if (element.offsetTop < parent.scrollTop) {\n    parent.scrollTop = element.offsetTop;\n  } // Anchor to bottom of scroll parent.\n\n\n  if (element.offsetTop + element.clientHeight > parent.scrollTop + parent.clientHeight) {\n    parent.scrollTop = element.offsetTop + element.clientHeight - parent.clientHeight;\n  }\n}\n/**\n * Calls `scrollIntoView` on the provided element with sensible defaults. If\n * the element does not existed or does not support the `scrollIntoView`\n * method, it will do nothing. This wrapper is created to support environments\n * where the native function is not available like JSDom (feature request:\n * https://github.com/jsdom/jsdom/issues/1422).\n *\n * @param element to be scrolled into view\n * @param options native options for `scrollIntoView`\n */\n\nexport function scrollElementIntoView(element, options) {\n  var _a;\n\n  if (options === void 0) {\n    options = {\n      block: 'nearest',\n      inline: 'nearest'\n    };\n  }\n\n  (_a = element === null || element === void 0 ? void 0 : element.scrollIntoView) === null || _a === void 0 ? void 0 : _a.call(element, options);\n}","map":null,"metadata":{},"sourceType":"module"}