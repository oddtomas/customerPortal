{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { arc } from 'd3-shape';\nimport styles from './styles.css.js';\nimport { dimensionsBySize, balanceLabelNodes } from './utils';\nimport { useResizeObserver } from '../internal/hooks/container-queries';\nimport ResponsiveText from './responsive-text';\n\nfunction LabelElement(_a) {\n  var x = _a.x,\n      y = _a.y,\n      hideTitles = _a.hideTitles,\n      hideDescriptions = _a.hideDescriptions,\n      rightSide = _a.rightSide,\n      title = _a.title,\n      description = _a.description,\n      containerBoundaries = _a.containerBoundaries;\n  return (// Reset the transform property to prepare for `balanceLabelNodes`.\n    // The dataset attributes are also needed in the function for IE11 support.\n    React.createElement(\"g\", {\n      className: styles['label-text'],\n      transform: \"\",\n      \"data-x\": x,\n      \"data-y\": y\n    }, !hideTitles && React.createElement(ResponsiveText, {\n      x: x,\n      y: y,\n      rightSide: rightSide,\n      containerBoundaries: containerBoundaries\n    }, title), !hideDescriptions && description && React.createElement(ResponsiveText, {\n      x: x,\n      y: y + (hideTitles ? 0 : 18),\n      rightSide: rightSide,\n      className: styles.label__description,\n      containerBoundaries: containerBoundaries\n    }, description))\n  );\n}\n\nexport default (function (_a) {\n  var pieData = _a.pieData,\n      size = _a.size,\n      highlightedSegment = _a.highlightedSegment,\n      segmentDescription = _a.segmentDescription,\n      visibleDataSum = _a.visibleDataSum,\n      hideTitles = _a.hideTitles,\n      hideDescriptions = _a.hideDescriptions,\n      containerRef = _a.containerRef;\n  var containerBoundaries = useElementBoundaries(containerRef);\n  var markers = useMemo(function () {\n    var _a = dimensionsBySize[size],\n        radius = _a.outerRadius,\n        innerLabelPadding = _a.innerLabelPadding; // More arc factories for the label positioning\n\n    var arcMarkerStart = arc().innerRadius(radius - 1).outerRadius(radius - 1);\n    var arcMarkerBreak = arc().innerRadius(radius + innerLabelPadding).outerRadius(radius + innerLabelPadding);\n    return pieData.map(function (datum, i) {\n      var labelDatum = pieData[i];\n      var midAngle = labelDatum.startAngle + (labelDatum.endAngle - labelDatum.startAngle) / 2; // Make the marker line longer if the segment is closer to the top or bottom of the chart\n\n      arcMarkerBreak.outerRadius(radius + 20 * (0.5 * Math.cos(2 * midAngle) + 0.5));\n      arcMarkerBreak.innerRadius(radius + 20 * (0.5 * Math.cos(2 * midAngle) + 0.5));\n\n      var _a = arcMarkerStart.centroid(datum),\n          startX = _a[0],\n          startY = _a[1];\n\n      var _b = arcMarkerBreak.centroid(datum),\n          breakX = _b[0],\n          breakY = _b[1];\n\n      var rightSide = midAngle < Math.PI;\n      var endX = (radius + 20) * (rightSide ? 1 : -1);\n      var textX = endX + 5 * (rightSide ? 1 : -1);\n      return {\n        startX: startX,\n        startY: startY,\n        breakX: breakX,\n        breakY: breakY,\n        endX: endX,\n        endY: breakY,\n        textX: textX,\n        textY: breakY,\n        rightSide: rightSide,\n        datum: datum\n      };\n    });\n  }, [pieData, size]);\n  var rootRef = useRef(null);\n  useLayoutEffect(function () {\n    if (!rootRef.current) {\n      return;\n    } // Relax labels that are overlapping\n\n\n    var labelNodes = rootRef.current.querySelectorAll(\".\".concat(styles['label-text']));\n    balanceLabelNodes(labelNodes, markers, false);\n    balanceLabelNodes(labelNodes, markers, true);\n  }, [markers, pieData]);\n  return React.createElement(\"g\", {\n    className: styles.markers,\n    \"aria-hidden\": \"true\",\n    ref: rootRef\n  }, markers.map(function (_a) {\n    var _b;\n\n    var startX = _a.startX,\n        startY = _a.startY,\n        breakX = _a.breakX,\n        breakY = _a.breakY,\n        endX = _a.endX,\n        endY = _a.endY,\n        textX = _a.textX,\n        textY = _a.textY,\n        rightSide = _a.rightSide,\n        datum = _a.datum;\n    var segment = datum.data.datum;\n    var description = segmentDescription === null || segmentDescription === void 0 ? void 0 : segmentDescription(segment, visibleDataSum);\n\n    if (hideTitles && !description || hideDescriptions && !segment.title) {\n      return null;\n    }\n\n    return React.createElement(\"g\", {\n      key: datum.data.index,\n      className: clsx(styles.label, (_b = {}, _b[styles['label--highlighted']] = highlightedSegment === segment, _b[styles['label--dimmed']] = highlightedSegment !== null && highlightedSegment !== segment, _b[styles['label--align-right']] = !rightSide, _b))\n    }, React.createElement(\"line\", {\n      x1: startX,\n      y1: startY,\n      x2: breakX,\n      y2: breakY\n    }), React.createElement(\"line\", {\n      x1: breakX,\n      y1: breakY,\n      x2: endX,\n      y2: endY,\n      className: styles['label-line']\n    }), React.createElement(LabelElement, {\n      x: textX,\n      y: textY,\n      rightSide: rightSide,\n      title: segment.title,\n      description: description,\n      hideTitles: hideTitles,\n      hideDescriptions: hideDescriptions,\n      containerBoundaries: containerBoundaries\n    }));\n  }));\n});\n\nfunction useElementBoundaries(ref) {\n  var _a = useState({\n    left: 0,\n    right: 0\n  }),\n      state = _a[0],\n      setState = _a[1];\n\n  useResizeObserver(ref, function (entry) {\n    var elementRect = entry.target.getBoundingClientRect();\n    setState({\n      left: elementRect.left,\n      right: elementRect.right\n    });\n  });\n  return state;\n}","map":null,"metadata":{},"sourceType":"module"}