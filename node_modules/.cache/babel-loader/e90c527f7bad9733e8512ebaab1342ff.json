{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useLayoutEffect, useCallback } from 'react';\nimport { useResizeObserver } from '../internal/hooks/container-queries/use-resize-observer';\nimport stickyScrolling, { calculateScrollingOffset, scrollUpBy } from './sticky-scrolling';\nimport { useMobile } from '../internal/hooks/use-mobile';\n\nfunction syncSizes(from, to) {\n  var fromCells = Array.prototype.slice.apply(from.children);\n  var toCells = Array.prototype.slice.apply(to.children);\n\n  for (var i = 0; i < fromCells.length; i++) {\n    var width = fromCells[i].style.width; // use auto if it is set by resizable columns or real size otherwise\n\n    if (width !== 'auto') {\n      width = \"\".concat(fromCells[i].offsetWidth, \"px\");\n    }\n\n    toCells[i].style.width = width;\n  }\n}\n\nexport var useStickyHeader = function useStickyHeader(tableRef, theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef) {\n  var isMobile = useMobile(); // Sync the sizes of the column header copies in the sticky header with the originals\n\n  var syncColumnHeaderWidths = useCallback(function () {\n    if (tableRef.current && theadRef.current && secondaryTheadRef.current && secondaryTableRef.current && tableWrapperRef.current) {\n      syncSizes(theadRef.current, secondaryTheadRef.current); // Using the tableRef offsetWidth instead of the theadRef because in VR\n      // the tableRef adds extra padding to the table and by default the theadRef will have a width\n      // without the padding and will make the sticky header width incorrect.\n\n      secondaryTableRef.current.style.width = \"\".concat(tableRef.current.offsetWidth, \"px\");\n      tableWrapperRef.current.style.marginTop = \"-\".concat(theadRef.current.offsetHeight, \"px\");\n    }\n  }, [theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef, tableRef]);\n  useLayoutEffect(function () {\n    syncColumnHeaderWidths(); // Content is not going to be layed out until the next frame in angular,\n    // so we need to sync the column headers again.\n\n    setTimeout(function () {\n      return syncColumnHeaderWidths();\n    }, 0);\n    var secondaryTable = secondaryTableRef.current;\n    var primaryTable = tableWrapperRef.current;\n    return function () {\n      if (secondaryTable) {\n        secondaryTable.style.width = '';\n      }\n\n      if (primaryTable) {\n        primaryTable.style.marginTop = '';\n      }\n    };\n  });\n  useResizeObserver(theadRef, syncColumnHeaderWidths);\n\n  var scrollToTop = function scrollToTop() {\n    if (!isMobile && theadRef.current && secondaryTheadRef.current && tableWrapperRef.current) {\n      var scrollDist = calculateScrollingOffset(theadRef.current, secondaryTheadRef.current);\n\n      if (scrollDist > 0) {\n        scrollUpBy(scrollDist, tableWrapperRef.current);\n      }\n    }\n  };\n\n  var scrollToItem = stickyScrolling(tableWrapperRef, secondaryTheadRef).scrollToItem;\n\n  var scrollToRow = function scrollToRow(itemNode) {\n    if (!isMobile) {\n      scrollToItem(itemNode);\n    }\n  };\n\n  return {\n    scrollToRow: scrollToRow,\n    scrollToTop: scrollToTop\n  };\n};","map":null,"metadata":{},"sourceType":"module"}