{"ast":null,"code":"/**\n * Combine all line series into an array of scaled data points with the given scales.\n */\nexport default function makeScaledSeries(series, xScale, yScale) {\n  var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n\n  var scaleX = function scaleX(x) {\n    return (xScale.d3Scale(x) || 0) + xOffset;\n  };\n\n  var scaleY = function scaleY(y) {\n    return yScale.d3Scale(y) || 0;\n  };\n\n  var allScaledX = getAllScaledX(series, scaleX); // Support threshold-only setup.\n\n  if (allScaledX.length === 0) {\n    allScaledX.push(NaN);\n  }\n\n  return series.reduce(function (acc, _a) {\n    var series = _a.series,\n        color = _a.color;\n\n    if (series.type === 'line') {\n      for (var _i = 0, _b = series.data; _i < _b.length; _i++) {\n        var datum = _b[_i];\n        acc.push({\n          x: scaleX(datum.x),\n          y: scaleY(datum.y),\n          datum: datum,\n          series: series,\n          color: color\n        });\n      }\n    } else if (series.type === 'threshold') {\n      for (var _c = 0, allScaledX_1 = allScaledX; _c < allScaledX_1.length; _c++) {\n        var x = allScaledX_1[_c];\n        acc.push({\n          x: x,\n          y: scaleY(series.y),\n          series: series,\n          color: color\n        });\n      }\n    }\n\n    return acc;\n  }, []);\n}\n/**\n * Collect unique x values from all data series.\n */\n\nfunction getAllScaledX(series, scaleX) {\n  var addDataXSet = new Set();\n\n  for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\n    var s = series_1[_i].series;\n\n    if (s.type !== 'threshold') {\n      for (var _a = 0, _b = s.data; _a < _b.length; _a++) {\n        var d = _b[_a];\n        addDataXSet.add(scaleX(d.x));\n      }\n    }\n  }\n\n  var allDataX = [];\n  addDataXSet.forEach(function (x) {\n    return allDataX.push(x);\n  });\n  return allDataX;\n}","map":null,"metadata":{},"sourceType":"module"}