{"ast":null,"code":"// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nvar EPSILON = 0.0000000000001; // When x-domain is not set explicitly - guess it based on the available data.\n\nexport function computeDomainX(series) {\n  var xValues = getXValues(series);\n\n  if (xValues.length === 0) {\n    return [];\n  } // Assuming categorical domain.\n  // In that case, all values are to be included.\n\n\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues);\n  } // For non-categorical domain find min and max bounds.\n\n\n  return xValues.reduce(function (_a, x) {\n    var min = _a[0],\n        max = _a[1];\n    return [x < min ? x : min, max < x ? x : max];\n  }, [xValues[0], xValues[0]]);\n} // When y-domain is not set explicitly - guess it based on the available data and series.\n\nexport function computeDomainY(series, scaleType) {\n  var min = Number.POSITIVE_INFINITY;\n  var max = Number.NEGATIVE_INFINITY; // Find the min and max for threshold series.\n\n  series.forEach(function (s) {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  }); // Find the min and max for area series considering their stacking.\n\n  getXValues(series).forEach(function (_, xIndex) {\n    var _a; // Maintains the prev stack level.\n\n\n    var stackY = scaleType === 'linear' ? 0 : EPSILON;\n\n    for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {\n      var s = series_1[_i];\n\n      if (s.type === 'area') {\n        stackY = stackY + (((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  }); // If min/max is not overridden than either series or series data is empty.\n\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  } // Log scales can't start from 0, so, if possible, start from 1.\n\n\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n\n  return [min, max];\n} // For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\n\nexport function computePlotPoints(series, xScale, yScale) {\n  var xValues = getXValues(series); // Lookup for xy[xIndex][yIndex]\n\n  var xy = []; // Lookup for xs[xIndex][seriesIndex]\n\n  var xs = []; // Lookup for sx[seriesIndex][xIndex]\n\n  var sx = []; // Filter out the data which is beyond the plot for whatever reason.\n\n  getVisibleData(xValues, xScale).forEach(function (_a, xIndex) {\n    var x = _a.x,\n        scaledX = _a.scaledX; // Maintains the prev stack level. Starting from epsilon to not break log scales.\n\n    var stackY = yScale.scaleType === 'linear' ? 0 : EPSILON; // A column of series points related to the same x.\n\n    var points = []; // Collect the points, leaving y-index as 0 for now.\n\n    series.forEach(function (s, sIndex) {\n      var _a;\n\n      if (s.type === 'threshold') {\n        var scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: {\n            x: scaledX,\n            y0: scaledY,\n            y1: scaledY\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: 0\n        });\n      } else {\n        var value = ((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0;\n        var y0 = stackY;\n        var y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: {\n            x: scaledX,\n            y0: yScale.d3Scale(y0) || 0,\n            y1: yScale.d3Scale(y1) || 0\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: value\n        });\n        stackY = y1;\n      }\n    }); // Sort points by y and insert the missing y-index.\n\n    points.sort(function (p1, p2) {\n      return p1.y1 - p2.y1;\n    }).forEach(function (point, index) {\n      point.index.y = index; // Insert the points to the respective two-dimensional lookup arrays.\n\n      insertIntoMatrix(xy, point.index.x, point.index.y, point);\n      insertIntoMatrix(xs, point.index.x, point.index.s, point);\n      insertIntoMatrix(sx, point.index.s, point.index.x, point);\n    });\n  });\n  return {\n    xy: xy,\n    xs: xs,\n    sx: sx\n  };\n} // Finds the closest point in the sorted array.\n\nexport function findClosest(sortedArray, target, getter) {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n\n  var isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n\n  var compare = function compare(x) {\n    return isAscending ? getter(x) < target : getter(x) > target;\n  };\n\n  var delta = function delta(x) {\n    return Math.abs(getter(x) - target);\n  }; // Use binary search to find the closest value in a sorted array.\n\n\n  var lo = 0;\n  var hi = sortedArray.length - 1;\n\n  while (hi - lo > 1) {\n    var mid = Math.floor((lo + hi) / 2);\n\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n} // Returns given index if it is in range or the opposite range boundary otherwise.\n\nexport function circleIndex(index, _a) {\n  var from = _a[0],\n      to = _a[1];\n\n  if (index < from) {\n    return to;\n  }\n\n  if (index > to) {\n    return from;\n  }\n\n  return index;\n} // Delays function execution\n\nexport function throttle(func, delay) {\n  var pending = null;\n  var lastInvokeTime = null;\n  var timerId = null; // Runs on every animation frame until timer stopped.\n\n  function pendingFunc() {\n    if (pending && lastInvokeTime !== null) {\n      var time = Date.now();\n      var shouldInvoke = time - lastInvokeTime >= delay;\n\n      if (shouldInvoke) {\n        func.apply(pending[\"this\"], pending.args);\n        lastInvokeTime = time;\n        pending = null;\n      } else {\n        startTimer();\n      }\n    }\n  }\n\n  function startTimer() {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n\n    timerId = requestAnimationFrame(pendingFunc);\n  } // Decorated client function with delay mechanism.\n\n\n  function throttled() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (lastInvokeTime === null) {\n      func.apply(this, args);\n      lastInvokeTime = Date.now();\n    } else {\n      pending = {\n        \"this\": this,\n        args: args\n      };\n      startTimer();\n    }\n  } // Prevents delayed function from execution when no longer needed.\n\n\n  throttled.cancel = function () {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n\n    pending = null;\n    lastInvokeTime = null;\n    timerId = null;\n  };\n\n  return throttled;\n} // Compares all x-values between series to ensure they are consistent.\n\nexport function isSeriesValid(series) {\n  var _a;\n\n  var sampleXValues = getXValues(series);\n\n  for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {\n    var s = series_2[_i];\n\n    if (s.type === 'area') {\n      for (var i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (((_a = s.data[i]) === null || _a === void 0 ? void 0 : _a.x) !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n} // Takes first area series x-values as all data x-values are to match across series.\n\nfunction getXValues(series) {\n  for (var _i = 0, series_3 = series; _i < series_3.length; _i++) {\n    var s = series_3[_i];\n\n    if (s.type === 'area') {\n      return s.data.map(function (_a) {\n        var x = _a.x;\n        return x;\n      });\n    }\n  }\n\n  return [];\n} // Returns data that is visible in the given scale.\n\n\nfunction getVisibleData(data, xScale) {\n  var scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var visibleData = [];\n\n  for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n    var x = data_1[_i];\n    var scaledX = xScale.d3Scale(x);\n\n    if (scaledX !== undefined) {\n      visibleData.push({\n        x: x,\n        scaledX: scaledX + scaledOffsetX\n      });\n    }\n  }\n\n  return visibleData;\n} // Inserts given value into a two-dimensional array.\n\n\nfunction insertIntoMatrix(matrix, row, col, value) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n\n  matrix[row][col] = value;\n} // Creates new array with only unique elements of the given array.\n\n\nfunction uniq(arr) {\n  var set = new Set();\n  var uniqArray = [];\n\n  for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {\n    var value = arr_1[_i];\n\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n\n  return uniqArray;\n}","map":null,"metadata":{},"sourceType":"module"}