{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nimport { useContainerBreakpoints, useContainerQuery } from '../internal/hooks/container-queries';\nimport styles from './styles.css.js'; // A small buffer to make calculations more lenient against browser lag or padding adjustments.\n\nvar RESPONSIVENESS_BUFFER = 20;\nexport function useTopNavigation(_a) {\n  var identity = _a.identity,\n      search = _a.search,\n      utilities = _a.utilities; // Refs and breakpoints\n\n  var mainRef = useRef(null);\n  var virtualRef = useRef(null);\n\n  var _b = useContainerBreakpoints(['xxs', 's']),\n      breakpoint = _b[0],\n      breakpointRef = _b[1]; // Responsiveness state\n  // The component works by calculating the possible resize states that it can\n  // be in, and having a state variable to track which state we're currently in.\n\n\n  var hasSearch = !!search;\n  var hasTitleWithLogo = identity && !!identity.logo && !!identity.title;\n  var responsiveStates = useMemo(function () {\n    return generateResponsiveStateKeys(utilities, hasSearch, hasTitleWithLogo);\n  }, [utilities, hasSearch, hasTitleWithLogo]); // To hide/show elements dynamically, we need to know how much space they take up,\n  // even if they're not being rendered. The top navigation elements are hidden/resized\n  // based on the available size or if a search bar is open, and they need to be available\n  // for calculations so we know where to toggle them. So we render a second, more stable\n  // top-nav off screen to do these calculations against.\n  //\n  // We can't \"affix\" these values to pixels because they can depend on spacing tokens.\n  // It's easier to render all of these utilities separately rather than figuring out\n  // spacing token values, icon sizes, text widths, etc.\n\n  var _c = useState(),\n      responsiveState = _c[0],\n      setResponsiveState = _c[1];\n\n  var recalculateFit = useCallback(function () {\n    var _a, _b, _c, _d;\n\n    if (!(mainRef === null || mainRef === void 0 ? void 0 : mainRef.current) || !virtualRef.current) {\n      setResponsiveState(responsiveStates[0]);\n      return;\n    } // Get available width from the visible top navigation.\n\n\n    var availableWidth = getContentBoxWidth(mainRef.current.querySelector(\".\".concat(styles['padding-box'])));\n\n    if (availableWidth === 0) {\n      // Likely in an SSR or Jest situation.\n      setResponsiveState(responsiveStates[0]);\n      return;\n    }\n\n    var sizeConfiguration = {\n      hasSearch: hasSearch,\n      availableWidth: availableWidth,\n      // Get widths from the hidden top navigation\n      fullIdentityWidth: virtualRef.current.querySelector(\".\".concat(styles.identity)).getBoundingClientRect().width,\n      titleWidth: (_b = (_a = virtualRef.current.querySelector(\".\".concat(styles.title))) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width) !== null && _b !== void 0 ? _b : 0,\n      searchSlotWidth: (_d = (_c = virtualRef.current.querySelector(\".\".concat(styles.search))) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect().width) !== null && _d !== void 0 ? _d : 0,\n      searchUtilityWidth: virtualRef.current.querySelector('[data-utility-special=\"search\"]').getBoundingClientRect().width,\n      utilitiesLeftPadding: parseFloat(getComputedStyle(virtualRef.current.querySelector(\".\".concat(styles.utilities))).paddingLeft || '0px'),\n      utilityWithLabelWidths: Array.prototype.slice.call(virtualRef.current.querySelectorAll(\"[data-utility-hide=\\\"false\\\"]\")).map(function (element) {\n        return element.getBoundingClientRect().width;\n      }),\n      utilityWithoutLabelWidths: Array.prototype.slice.call(virtualRef.current.querySelectorAll(\"[data-utility-hide=\\\"true\\\"]\")).map(function (element) {\n        return element.getBoundingClientRect().width;\n      }),\n      menuTriggerUtilityWidth: virtualRef.current.querySelector('[data-utility-special=\"menu-trigger\"]').getBoundingClientRect().width\n    };\n    setResponsiveState(determineBestResponsiveState(responsiveStates, sizeConfiguration));\n  }, [responsiveStates, hasSearch]);\n\n  var _d = useContainerQuery(function () {\n    recalculateFit();\n  }, [recalculateFit]),\n      containerQueryRef = _d[1]; // Due to being rendered in a portal, the virtual navigation isn't rendered\n  // at the same time as the main one.\n\n\n  var onVirtualMount = useCallback(function (element) {\n    virtualRef.current = element;\n    recalculateFit();\n  }, [recalculateFit]); // Search slot expansion on small screens\n\n  var _e = useState(true),\n      isSearchMinimized = _e[0],\n      setSearchMinimized = _e[1];\n\n  var isSearchExpanded = !isSearchMinimized && hasSearch && (responsiveState === null || responsiveState === void 0 ? void 0 : responsiveState.hideSearch); // If the search was expanded, and then the screen resized so that the\n  // expansion is no longer necessary. So we implicitly minimize it.\n\n  useEffect(function () {\n    if (!(responsiveState === null || responsiveState === void 0 ? void 0 : responsiveState.hideSearch)) {\n      setSearchMinimized(true);\n    }\n  }, [responsiveState]); // If the search is expanded after clicking on the search utility, move\n  // the focus to the input. Since this is a user-controlled slot, we're just\n  // assuming that it contains an input, though it's a pretty safe guess.\n\n  useEffect(function () {\n    var _a, _b;\n\n    if (isSearchExpanded) {\n      (_b = (_a = mainRef === null || mainRef === void 0 ? void 0 : mainRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(styles.search, \" input\"))) === null || _b === void 0 ? void 0 : _b.focus();\n    }\n  }, [isSearchExpanded, mainRef]);\n  var mergedMainRef = useMergeRefs(mainRef, containerQueryRef, breakpointRef);\n  return {\n    mainRef: mergedMainRef,\n    virtualRef: onVirtualMount,\n    responsiveState: responsiveState !== null && responsiveState !== void 0 ? responsiveState : responsiveStates[0],\n    breakpoint: breakpoint !== null && breakpoint !== void 0 ? breakpoint : 'default',\n    isSearchExpanded: !!isSearchExpanded,\n    onSearchUtilityClick: function onSearchUtilityClick() {\n      return setSearchMinimized(function (isSearchMinimized) {\n        return !isSearchMinimized;\n      });\n    }\n  };\n}\n/**\n * Get the width of the content box (assuming the element's box-sizing is border-box).\n */\n\nfunction getContentBoxWidth(element) {\n  var style = getComputedStyle(element);\n  return parseFloat(style.width || '0px') - parseFloat(style.paddingLeft || '0px') - parseFloat(style.paddingRight || '0px');\n}\n/**\n * Generates the series of responsive steps that can be performed on the header in order.\n */\n\n\nexport function generateResponsiveStateKeys(utilities, canHideSearch, canHideTitle) {\n  var states = [{}];\n\n  if (utilities.some(function (utility) {\n    return utility.text;\n  })) {\n    states.push({\n      hideUtilityText: true\n    });\n  }\n\n  if (canHideSearch) {\n    states.push({\n      hideUtilityText: true,\n      hideSearch: true\n    });\n  }\n\n  var hiddenUtilties = [];\n\n  for (var i = 0; i < utilities.length; i++) {\n    if (!utilities[i].disableUtilityCollapse) {\n      hiddenUtilties.push(i);\n      states.push({\n        hideUtilityText: true,\n        hideSearch: canHideSearch || undefined,\n        hideUtilities: hiddenUtilties.length > 0 ? hiddenUtilties.slice() : undefined\n      });\n    }\n  }\n\n  if (canHideTitle) {\n    states.push({\n      hideUtilityText: true,\n      hideSearch: canHideSearch || undefined,\n      hideUtilities: hiddenUtilties.length > 0 ? hiddenUtilties.slice() : undefined,\n      hideTitle: true\n    });\n  }\n\n  return states;\n}\n/**\n * Determines the best responsive state configuration of the top navigation, based on the given list of possible responsive states\n * and the current sizes of all elements inside the navigation bar.\n */\n\nexport function determineBestResponsiveState(possibleStates, sizes) {\n  var hasSearch = sizes.hasSearch,\n      availableWidth = sizes.availableWidth,\n      utilitiesLeftPadding = sizes.utilitiesLeftPadding,\n      fullIdentityWidth = sizes.fullIdentityWidth,\n      titleWidth = sizes.titleWidth,\n      searchSlotWidth = sizes.searchSlotWidth,\n      searchUtilityWidth = sizes.searchUtilityWidth,\n      utilityWithLabelWidths = sizes.utilityWithLabelWidths,\n      utilityWithoutLabelWidths = sizes.utilityWithoutLabelWidths,\n      menuTriggerUtilityWidth = sizes.menuTriggerUtilityWidth;\n\n  var _loop_1 = function _loop_1(state) {\n    var searchWidth = hasSearch ? state.hideSearch ? searchUtilityWidth : searchSlotWidth : 0;\n    var utilitiesWidth = (state.hideUtilityText ? utilityWithoutLabelWidths : utilityWithLabelWidths).filter(function (_width, i) {\n      return !state.hideUtilities || state.hideUtilities.indexOf(i) === -1;\n    }).reduce(function (sum, width) {\n      return sum + width;\n    }, 0);\n    var menuTriggerWidth = state.hideUtilities ? menuTriggerUtilityWidth : 0;\n    var identityWidth = state.hideTitle ? fullIdentityWidth - titleWidth : fullIdentityWidth;\n    var expectedInnerWidth = identityWidth + searchWidth + utilitiesLeftPadding + utilitiesWidth + menuTriggerWidth;\n\n    if (expectedInnerWidth <= availableWidth - RESPONSIVENESS_BUFFER) {\n      return {\n        value: state\n      };\n    }\n  }; // Iterate through each state and calculate its expected required width.\n\n\n  for (var _i = 0, possibleStates_1 = possibleStates; _i < possibleStates_1.length; _i++) {\n    var state = possibleStates_1[_i];\n\n    var state_1 = _loop_1(state);\n\n    if (typeof state_1 === \"object\") return state_1.value;\n  } // If nothing matches, pick the smallest possible state.\n\n\n  return possibleStates[possibleStates.length - 1];\n}","map":null,"metadata":{},"sourceType":"module"}