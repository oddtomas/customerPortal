{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useState, useLayoutEffect, useCallback, useEffect, createContext, useMemo } from 'react';\nimport { useAppLayoutContext } from '../internal/context/app-layout-context';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport { findUpUntil, supportsStickyPosition } from '../internal/utils/dom';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport customCssProps from '../internal/generated/custom-css-properties';\nexport var StickyHeaderContext = createContext({\n  isStuck: false\n});\nexport var useStickyHeader = function useStickyHeader(rootRef, headerRef, __stickyHeader, __stickyOffset) {\n  var currentRootRef = rootRef.current;\n  var currentHeaderRef = headerRef.current;\n  var totalBorder = useMemo(function () {\n    var containerRootBorder = currentRootRef ? parseInt(getComputedStyle(currentRootRef).getPropertyValue('border-top-width'), 10) : 0;\n    var headerBorder = currentHeaderRef ? parseInt(getComputedStyle(currentHeaderRef).getPropertyValue('border-top-width'), 10) : 0;\n    return containerRootBorder + headerBorder;\n  }, [currentRootRef, currentHeaderRef]); // We reach into AppLayoutContext in case sticky header needs to be offset down by the height\n  // of other sticky elements positioned on top of the view.\n\n  var stickyOffsetTop = useAppLayoutContext().stickyOffsetTop;\n  var isSticky = useSupportsStickyHeader() && !!__stickyHeader;\n  var isRefresh = useVisualRefresh(rootRef); // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n\n  var _a = useState(false),\n      hasInnerOverflowParents = _a[0],\n      setHasInnerOverflowParents = _a[1];\n\n  var _b = useState(false),\n      isStuck = _b[0],\n      setIsStuck = _b[1];\n\n  useLayoutEffect(function () {\n    if (rootRef.current) {\n      var overflowParents = getOverflowParents(rootRef.current);\n      var mainElement = findUpUntil(rootRef.current, function (elem) {\n        return elem.tagName === 'MAIN';\n      }); // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n  var effectiveStickyOffset = __stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : hasInnerOverflowParents ? 0 : stickyOffsetTop;\n  /**\n   * The AppLayout refactor removed the need for passing the sticky offset in px all the time through the\n   * AppLayoutDomContext provider because that information already exists on the DOM in a custom property\n   * on the Layout subcomponent. Thus, if the Container header is sticky, we are in Visual Refresh and use\n   * body scroll then we will use that property. When a component is used outside AppLayout, we fall back\n   * to the default offset calculated in AppLayoutDomContext.\n   */\n\n  var computedOffset = \"\".concat(effectiveStickyOffset - totalBorder, \"px\");\n\n  if (isRefresh && !hasInnerOverflowParents) {\n    computedOffset = \"var(\".concat(customCssProps.offsetTopWithNotifications, \", \").concat(computedOffset, \")\");\n  }\n\n  var stickyStyles = isSticky ? {\n    style: {\n      top: computedOffset\n    }\n  } : {}; // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n\n  var checkIfStuck = useCallback(function () {\n    if (rootRef.current && headerRef.current) {\n      var rootTop = rootRef.current.getBoundingClientRect().top;\n      var headerTop = headerRef.current.getBoundingClientRect().top;\n\n      if (rootTop + totalBorder < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n    }\n  }, [rootRef, headerRef, totalBorder]);\n  useEffect(function () {\n    if (isSticky) {\n      window.addEventListener('scroll', checkIfStuck, true);\n      window.addEventListener('resize', checkIfStuck);\n      return function () {\n        window.removeEventListener('scroll', checkIfStuck, true);\n        window.removeEventListener('resize', checkIfStuck);\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky: isSticky,\n    isStuck: isStuck,\n    stickyStyles: stickyStyles\n  };\n};\nexport function useSupportsStickyHeader() {\n  var isMobile = useMobile();\n  return supportsStickyPosition() && !isMobile;\n}","map":null,"metadata":{},"sourceType":"module"}