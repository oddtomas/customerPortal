{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useMemo, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { pie } from 'd3-shape';\nimport { KeyCode } from '../internal/keycode';\nimport { nodeContains } from '../internal/utils/dom';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport ChartPopover from '../internal/components/chart-popover';\nimport SeriesDetails from '../internal/components/chart-series-details';\nimport SeriesMarker from '../internal/components/chart-series-marker';\nimport ChartStatusContainer, { getChartStatus } from '../internal/components/chart-status-container';\nimport InternalBox from '../box/internal';\nimport Labels from './labels';\nimport styles from './styles.css.js';\nimport { defaultDetails, dimensionsBySize, refreshDimensionsBySize } from './utils';\nimport Segments from './segments';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport ChartPlot from '../internal/components/chart-plot';\nexport default (function (_a) {\n  var _b;\n\n  var _c;\n\n  var variant = _a.variant,\n      size = _a.size,\n      i18nStrings = _a.i18nStrings,\n      ariaLabel = _a.ariaLabel,\n      ariaLabelledby = _a.ariaLabelledby,\n      data = _a.data,\n      visibleData = _a.visibleData,\n      ariaDescription = _a.ariaDescription,\n      innerMetricValue = _a.innerMetricValue,\n      innerMetricDescription = _a.innerMetricDescription,\n      hideTitles = _a.hideTitles,\n      hideDescriptions = _a.hideDescriptions,\n      detailPopoverContent = _a.detailPopoverContent,\n      detailPopoverSize = _a.detailPopoverSize,\n      width = _a.width,\n      additionalFilters = _a.additionalFilters,\n      hideFilter = _a.hideFilter,\n      hideLegend = _a.hideLegend,\n      statusType = _a.statusType,\n      empty = _a.empty,\n      noMatch = _a.noMatch,\n      errorText = _a.errorText,\n      recoveryText = _a.recoveryText,\n      loadingText = _a.loadingText,\n      onRecoveryClick = _a.onRecoveryClick,\n      segmentDescription = _a.segmentDescription,\n      highlightedSegment = _a.highlightedSegment,\n      onHighlightChange = _a.onHighlightChange,\n      legendSegment = _a.legendSegment,\n      pinnedSegment = _a.pinnedSegment,\n      setPinnedSegment = _a.setPinnedSegment;\n  var plotRef = useRef(null);\n  var containerRef = useRef(null);\n  var focusedSegmentRef = useRef(null);\n  var popoverTrackRef = useRef(null);\n  var isRefresh = useVisualRefresh(containerRef);\n  var dimensions = isRefresh ? refreshDimensionsBySize[size] : dimensionsBySize[size];\n  var radius = dimensions.outerRadius;\n  var hasLabels = !(hideTitles && hideDescriptions);\n  var height = 2 * (radius + dimensions.padding + (hasLabels ? dimensions.paddingLabels : 0)); // Inner content is only available for donut charts and the inner description is not displayed for small charts\n\n  var hasInnerContent = variant === 'donut' && (innerMetricValue || innerMetricDescription && size !== 'small');\n  var innerMetricId = useUniqueId('awsui-pie-chart__inner');\n\n  var _d = useState(false),\n      isTooltipOpen = _d[0],\n      setTooltipOpen = _d[1];\n\n  var _e = useState(),\n      tooltipData = _e[0],\n      setTooltipData = _e[1];\n\n  var _f = useMemo(function () {\n    var dataSum = visibleData.reduce(function (sum, d) {\n      return sum + d.datum.value;\n    }, 0);\n    var pieFactory = pie() // Minimum 1% segment size\n    .value(function (d) {\n      return d.datum.value < dataSum / 100 ? dataSum / 100 : d.datum.value;\n    }).sort(null); // Filter out segments with value of zero or below\n\n    var pieData = pieFactory(visibleData.filter(function (d) {\n      return d.datum.value > 0;\n    }));\n    return {\n      pieData: pieData,\n      dataSum: dataSum\n    };\n  }, [visibleData]),\n      pieData = _f.pieData,\n      dataSum = _f.dataSum;\n\n  var highlightedSegmentIndex = useMemo(function () {\n    for (var index = 0; index < pieData.length; index++) {\n      if (pieData[index].data.datum === highlightedSegment) {\n        return index;\n      }\n    }\n\n    return null;\n  }, [pieData, highlightedSegment]);\n  var detailFunction = detailPopoverContent || defaultDetails(i18nStrings);\n  var details = tooltipData ? detailFunction(tooltipData.datum, dataSum) : [];\n  var tooltipContent = tooltipData && React.createElement(SeriesDetails, {\n    details: details\n  });\n\n  var _g = getChartStatus({\n    externalData: data,\n    visibleData: pieData,\n    statusType: statusType\n  }),\n      isEmpty = _g.isEmpty,\n      showChart = _g.showChart; // Pie charts have a special condition for empty/noMatch due to how zero-value segments are handled.\n\n\n  var isNoMatch = isEmpty && visibleData.length !== data.length;\n  var reserveLegendSpace = !showChart && !hideLegend;\n  var reserveFilterSpace = statusType !== 'finished' && !isNoMatch && (!hideFilter || additionalFilters);\n  var popoverDismissedRecently = useRef(false);\n  var highlightSegment = useCallback(function (internalDatum) {\n    var segment = internalDatum.datum;\n\n    if (segment !== highlightedSegment) {\n      onHighlightChange(segment);\n    }\n\n    if (popoverTrackRef.current) {\n      setTooltipData({\n        datum: internalDatum.datum,\n        series: {\n          color: internalDatum.color,\n          index: internalDatum.index,\n          label: internalDatum.datum.title,\n          markerType: 'rectangle'\n        },\n        trackRef: popoverTrackRef\n      });\n      setTooltipOpen(true);\n    }\n  }, [highlightedSegment, setTooltipOpen, onHighlightChange]);\n  var clearHighlightedSegment = useCallback(function () {\n    setTooltipOpen(false);\n    onHighlightChange(null);\n  }, [onHighlightChange, setTooltipOpen]);\n  var onClick = useCallback(function (internalDatum) {\n    if (pinnedSegment === internalDatum.datum) {\n      setPinnedSegment(null);\n      clearHighlightedSegment();\n    } else {\n      setPinnedSegment(internalDatum.datum);\n      highlightSegment(internalDatum);\n    }\n  }, [pinnedSegment, clearHighlightedSegment, setPinnedSegment, highlightSegment]);\n  var onMouseOver = useCallback(function (internalDatum) {\n    if (pinnedSegment !== null) {\n      return;\n    }\n\n    highlightSegment(internalDatum);\n  }, [pinnedSegment, highlightSegment]);\n  var onMouseOut = useCallback(function () {\n    if (pinnedSegment !== null) {\n      return;\n    }\n\n    clearHighlightedSegment();\n  }, [pinnedSegment, clearHighlightedSegment]);\n  var onKeyDown = useCallback(function (event) {\n    if (event.keyCode !== KeyCode.right && event.keyCode !== KeyCode.left && event.keyCode !== KeyCode.enter) {\n      return;\n    }\n\n    event.preventDefault();\n    var nextIndex = highlightedSegmentIndex || 0;\n    var MAX = pieData.length - 1;\n\n    if (event.keyCode === KeyCode.right) {\n      nextIndex++;\n\n      if (nextIndex > MAX) {\n        nextIndex = 0;\n      }\n    } else if (event.keyCode === KeyCode.left) {\n      nextIndex--;\n\n      if (nextIndex < 0) {\n        nextIndex = MAX;\n      }\n    }\n\n    if (event.keyCode === KeyCode.enter) {\n      setPinnedSegment(pieData[nextIndex].data.datum);\n    }\n\n    highlightSegment(pieData[nextIndex].data);\n  }, [setPinnedSegment, highlightSegment, pieData, highlightedSegmentIndex]);\n  var onFocus = useCallback(function (_event, target) {\n    // We need to make sure that we do not re-show the popover when we focus the segment after the popover is dismissed.\n    // Normally we would check `event.relatedTarget` for the previously focused element,\n    // but this is not supported for SVG elements in IE11. The workaround is this `popoverDismissedRecently` ref.\n    if (pinnedSegment !== null || popoverDismissedRecently.current || target === 'mouse') {\n      return;\n    }\n\n    var segment = highlightedSegment || legendSegment || pieData[0].data.datum;\n    var matched = pieData.filter(function (d) {\n      return d.data.datum === segment;\n    });\n    highlightSegment(matched[0].data);\n  }, [pinnedSegment, pieData, highlightSegment, highlightedSegment, legendSegment]);\n  var onBlur = useCallback(function (event) {\n    var blurTarget = event.relatedTarget || event.target;\n\n    if (blurTarget === null || !(blurTarget instanceof Element) || !nodeContains(containerRef.current, blurTarget)) {\n      // We only need to close the tooltip and remove the pinned segment so that we keep track of the current\n      // highlighted legendSeries. using clearHighlightedSegment() would set the legendSeries to null, in that case\n      // using Keyboard Tab will always highlight the first legend item in the legend component.\n      setTooltipOpen(false);\n      setPinnedSegment(null);\n    }\n  }, [setPinnedSegment]);\n\n  var onPopoverDismiss = function onPopoverDismiss(outsideClick) {\n    setTooltipOpen(false);\n    setPinnedSegment(null);\n\n    if (!outsideClick) {\n      // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.\n      setTimeout(function () {\n        popoverDismissedRecently.current = true;\n        plotRef.current.focusApplication();\n        popoverDismissedRecently.current = false;\n      }, 0);\n    }\n  };\n\n  return React.createElement(\"div\", {\n    className: clsx(styles.content, styles[\"content--\".concat(size)], (_b = {}, _b[styles['content--without-labels']] = !hasLabels, _b[styles['content--reserve-filter']] = reserveFilterSpace, _b[styles['content--reserve-legend']] = reserveLegendSpace, _b))\n  }, React.createElement(ChartStatusContainer, {\n    isEmpty: isEmpty,\n    isNoMatch: isNoMatch,\n    showChart: showChart,\n    statusType: statusType,\n    empty: empty,\n    noMatch: noMatch,\n    loadingText: loadingText,\n    errorText: errorText,\n    recoveryText: recoveryText,\n    onRecoveryClick: onRecoveryClick\n  }), showChart && React.createElement(\"div\", {\n    className: styles['chart-container'],\n    ref: containerRef\n  }, React.createElement(ChartPlot, {\n    ref: plotRef,\n    width: width,\n    height: height,\n    transform: \"translate(\".concat(width / 2, \" \").concat(height / 2, \")\"),\n    isPrecise: true,\n    isClickable: !isTooltipOpen,\n    ariaLabel: ariaLabel,\n    ariaLabelledby: ariaLabelledby,\n    ariaDescription: ariaDescription,\n    ariaDescribedby: hasInnerContent ? innerMetricId : undefined,\n    ariaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.chartAriaRoleDescription,\n    ariaLiveRegion: tooltipContent,\n    activeElementRef: focusedSegmentRef,\n    activeElementKey: highlightedSegmentIndex === null || highlightedSegmentIndex === void 0 ? void 0 : highlightedSegmentIndex.toString(),\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onKeyDown: onKeyDown\n  }, React.createElement(Segments, {\n    pieData: pieData,\n    size: size,\n    variant: variant,\n    containerRef: containerRef,\n    focusedSegmentRef: focusedSegmentRef,\n    popoverTrackRef: popoverTrackRef,\n    highlightedSegment: highlightedSegment,\n    segmentAriaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.segmentAriaRoleDescription,\n    onClick: onClick,\n    onMouseOver: onMouseOver,\n    onMouseOut: onMouseOut\n  }), hasLabels && React.createElement(Labels, {\n    pieData: pieData,\n    size: size,\n    segmentDescription: segmentDescription,\n    visibleDataSum: dataSum,\n    hideTitles: hideTitles,\n    hideDescriptions: hideDescriptions,\n    highlightedSegment: highlightedSegment,\n    containerRef: containerRef\n  })), hasInnerContent && React.createElement(\"div\", {\n    className: styles['inner-content'],\n    id: innerMetricId\n  }, innerMetricValue && React.createElement(InternalBox, {\n    variant: size === 'small' ? 'h3' : 'h1',\n    tagOverride: \"div\",\n    color: \"inherit\",\n    padding: \"n\"\n  }, innerMetricValue), innerMetricDescription && size !== 'small' && React.createElement(InternalBox, {\n    variant: \"h3\",\n    color: \"text-body-secondary\",\n    tagOverride: \"div\",\n    padding: \"n\"\n  }, innerMetricDescription)), isTooltipOpen && tooltipData && React.createElement(ChartPopover, {\n    title: tooltipData.series && React.createElement(InternalBox, {\n      className: styles['popover-header'],\n      variant: \"strong\"\n    }, React.createElement(SeriesMarker, {\n      color: tooltipData.series.color,\n      type: tooltipData.series.markerType\n    }), ' ', tooltipData.series.label),\n    trackRef: tooltipData.trackRef,\n    trackKey: tooltipData.series.index,\n    dismissButton: pinnedSegment !== null,\n    dismissAriaLabel: i18nStrings.detailPopoverDismissAriaLabel,\n    onDismiss: onPopoverDismiss,\n    container: ((_c = plotRef.current) === null || _c === void 0 ? void 0 : _c.svg) || null,\n    size: detailPopoverSize\n  }, tooltipContent)));\n});","map":null,"metadata":{},"sourceType":"module"}