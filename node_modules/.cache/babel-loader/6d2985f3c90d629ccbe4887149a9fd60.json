{"ast":null,"code":"import { useEffect, useMemo, useRef } from 'react';\nimport { findClosest, circleIndex, throttle } from './utils';\nimport { nodeContains } from '../../internal/utils/dom';\nimport { KeyCode } from '../../internal/keycode';\nimport { useReaction } from './async-store';\nimport computeChartProps from './compute-chart-props';\nimport createSeriesDecorator from './create-series-decorator';\nimport InteractionsStore from './interactions-store';\nimport { useStableEventHandler } from '../../internal/hooks/use-stable-event-handler';\nvar MAX_HOVER_MARGIN = 6;\nvar SVG_HOVER_THROTTLE = 25; // Represents the core the chart logic, including the model of all allowed user interactions.\n\nexport default function useChartModel(_a) {\n  var allSeries = _a.externalSeries,\n      series = _a.visibleSeries,\n      setVisibleSeries = _a.setVisibleSeries,\n      highlightedSeries = _a.highlightedSeries,\n      setHighlightedSeries = _a.setHighlightedSeries,\n      xDomain = _a.xDomain,\n      yDomain = _a.yDomain,\n      xScaleType = _a.xScaleType,\n      yScaleType = _a.yScaleType,\n      height = _a.height,\n      width = _a.width; // Chart elements refs used in handlers.\n\n  var plotRef = useRef(null);\n  var containerRef = useRef(null);\n  var verticalMarkerRef = useRef(null);\n  var stableSetVisibleSeries = useStableEventHandler(setVisibleSeries);\n  var model = useMemo(function () {\n    // Compute scales, ticks and two-dimensional plots.\n    var computed = computeChartProps({\n      series: series,\n      xDomain: xDomain,\n      yDomain: yDomain,\n      xScaleType: xScaleType,\n      yScaleType: yScaleType,\n      height: height,\n      width: width\n    }); // A store for chart interactions that don't require plot recomputation.\n\n    var interactions = new InteractionsStore(series, computed.plot); // A series decorator to provide extra props such as color and marker type.\n\n    var getInternalSeries = createSeriesDecorator(allSeries); // A Callback for svg mouseover to hover the plot points.\n    // Throttling is necessary for a substantially smoother customer experience.\n\n    var onSVGMouseMoveThrottled = throttle(function (clientX, clientY) {\n      // No hover logic when the popover is pinned or no data available.\n      if (interactions.get().isPopoverPinned || !plotRef.current || interactions.plot.xy.length === 0) {\n        return;\n      }\n\n      var svgRect = plotRef.current.svg.getBoundingClientRect();\n      var offsetX = clientX - svgRect.left;\n      var offsetY = clientY - svgRect.top;\n      var closestX = findClosest(interactions.plot.xy, offsetX, function (xPoints) {\n        return xPoints[0].scaled.x;\n      });\n      var closestPoint = findClosest(closestX, offsetY, function (point) {\n        return point.scaled.y1;\n      }); // If close enough to the point - highlight the point and its column.\n      // If not - only highlight the closest column.\n\n      if (Math.abs(offsetX - closestPoint.scaled.x) < MAX_HOVER_MARGIN && Math.abs(offsetY - closestPoint.scaled.y1) < MAX_HOVER_MARGIN) {\n        interactions.highlightPoint(closestPoint);\n      } else {\n        interactions.highlightX(closestX);\n      }\n    }, SVG_HOVER_THROTTLE);\n\n    var onSVGMouseMove = function onSVGMouseMove(_a) {\n      var clientX = _a.clientX,\n          clientY = _a.clientY;\n      return onSVGMouseMoveThrottled(clientX, clientY);\n    }; // A callback for svg mouseout to clear all highlights.\n\n\n    var onSVGMouseOut = function onSVGMouseOut(event) {\n      // Because the mouseover is throttled, in can occur slightly after the mouseout,\n      // neglecting its effect; cancelling the throttled function prevents that.\n      onSVGMouseMoveThrottled.cancel(); // No hover logic when the popover is pinned.\n\n      if (interactions.get().isPopoverPinned) {\n        return;\n      } // Check if the target is contained within svg to allow hovering on the popover body.\n\n\n      if (!nodeContains(plotRef.current.svg, event.relatedTarget)) {\n        interactions.clearHighlightedLegend();\n        interactions.clearHighlight();\n      }\n    }; // A callback for svg click to pin/unpin the popover.\n\n\n    var onSVGMouseDown = function onSVGMouseDown() {\n      interactions.togglePopoverPin();\n    }; // A helper function to highlight the next or previous point within selected series.\n\n\n    var moveWithinSeries = function moveWithinSeries(direction) {\n      // Can only use motion when a particular point is highlighted.\n      var point = interactions.get().highlightedPoint;\n\n      if (!point) {\n        return;\n      } // Take the index of the currently highlighted series.\n\n\n      var sIndex = point.index.s; // Take the incremented(circularly) x-index of the currently highlighted point.\n\n      var xIndex = circleIndex(point.index.x + direction, [0, interactions.plot.xs.length - 1]); // Highlight the next point using x:s grouped data.\n\n      interactions.highlightPoint(interactions.plot.xs[xIndex][sIndex]);\n    }; // A helper function to highlight the next or previous point withing selected column.\n\n\n    var moveBetweenSeries = function moveBetweenSeries(direction) {\n      // Can only use motion when a particular point is highlighted.\n      var point = interactions.get().highlightedPoint;\n\n      if (!point) {\n        return;\n      } // Take the index of the currently highlighted column.\n\n\n      var xIndex = point.index.x; // Take the incremented(circularly) y-index of the currently highlighted point.\n\n      var yIndex = circleIndex(point.index.y + direction, [0, interactions.plot.xy[xIndex].length - 1]); // Highlight the next point using x:y grouped data.\n\n      interactions.highlightPoint(interactions.plot.xy[xIndex][yIndex]);\n    }; // A callback for svg keydown to enable motions and popover pin with the keyboard.\n\n\n    var onSVGKeyDown = function onSVGKeyDown(event) {\n      var keyCode = event.keyCode;\n\n      if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n        return;\n      } // Preventing default fixes an issue in Safari+VO when VO additionally interprets arrow keys as its commands.\n\n\n      event.preventDefault(); // No keydown logic when the popover is pinned.\n\n      if (interactions.get().isPopoverPinned) {\n        return;\n      } // Move up/down.\n\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? -1 : 1);\n      } // Move left/right.\n      else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);\n      } // Pin popover.\n      else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        interactions.pinPopover();\n      }\n    }; // A callback for svg focus to highlight series.\n\n\n    var onSVGFocus = function onSVGFocus(_event, trigger) {\n      // When focus is caused by a click event nothing is expected as clicks are handled separately.\n      // Otherwise, select the first series point.\n      if (trigger === 'keyboard') {\n        interactions.highlightFirstPoint();\n      }\n    }; // A callback for svg blur to clear all highlights unless the popover is pinned.\n\n\n    var onSVGBlur = function onSVGBlur() {\n      // Pinned popover stays pinned even if the focus is lost.\n      // If blur is not caused by the popover, forget the previously highlighted point.\n      if (!interactions.get().isPopoverPinned) {\n        interactions.clearHighlight();\n      }\n    };\n\n    var onFilterSeries = function onFilterSeries(series) {\n      stableSetVisibleSeries(series);\n    };\n\n    var onLegendHighlight = function onLegendHighlight(series) {\n      interactions.highlightSeries(series);\n    };\n\n    var onPopoverDismiss = function onPopoverDismiss(outsideClick) {\n      interactions.unpinPopover(); // Return focus back to the application or plot (when no point is highlighted).\n\n      if (!outsideClick) {\n        // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.\n        setTimeout(function () {\n          if (interactions.get().highlightedPoint) {\n            plotRef.current.focusApplication();\n          } else {\n            interactions.clearHighlight();\n            plotRef.current.focusPlot();\n          }\n        }, 0);\n      }\n    };\n\n    var onContainerBlur = function onContainerBlur() {\n      interactions.clearState();\n    };\n\n    return {\n      width: width,\n      height: height,\n      series: series,\n      allSeries: allSeries,\n      getInternalSeries: getInternalSeries,\n      computed: computed,\n      interactions: interactions,\n      handlers: {\n        onSVGMouseMove: onSVGMouseMove,\n        onSVGMouseOut: onSVGMouseOut,\n        onSVGMouseDown: onSVGMouseDown,\n        onSVGKeyDown: onSVGKeyDown,\n        onSVGFocus: onSVGFocus,\n        onSVGBlur: onSVGBlur,\n        onFilterSeries: onFilterSeries,\n        onLegendHighlight: onLegendHighlight,\n        onPopoverDismiss: onPopoverDismiss,\n        onContainerBlur: onContainerBlur\n      },\n      refs: {\n        plot: plotRef,\n        container: containerRef,\n        verticalMarker: verticalMarkerRef\n      }\n    };\n  }, [allSeries, series, xDomain, yDomain, xScaleType, yScaleType, height, width, stableSetVisibleSeries]); // Notify client when series highlight change.\n\n  useReaction(model.interactions, function (state) {\n    return state.highlightedSeries;\n  }, setHighlightedSeries); // Update interactions store when series highlight in a controlled way.\n\n  useEffect(function () {\n    if (highlightedSeries !== model.interactions.get().highlightedSeries) {\n      model.interactions.highlightSeries(highlightedSeries);\n    }\n  }, [model, highlightedSeries]);\n  return model;\n}","map":null,"metadata":{},"sourceType":"module"}