{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useRef, useState } from 'react';\nimport { KeyCode } from '../../../internal/keycode';\nimport { addDays, addWeeks, isSameMonth, isAfter, isBefore, addMonths, min, max } from 'date-fns';\nimport InternalSpaceBetween from '../../../space-between/internal';\nimport { Grid } from './grid';\nimport styles from '../../styles.css.js';\nimport useFocusVisible from '../../../internal/hooks/focus-visible/index';\nimport { getBaseDate } from '../get-base-date';\nimport { hasValue } from '../../../internal/utils/has-value';\n\nfunction isVisible(date, baseDate, isSingleGrid) {\n  if (isSingleGrid) {\n    return isSameMonth(date, baseDate);\n  }\n\n  var previousMonth = addMonths(baseDate, -1);\n  return isSameMonth(date, previousMonth) || isSameMonth(date, baseDate);\n}\n\nexport function selectFocusedDate(selected, baseDate, isDateEnabled) {\n  if (selected && isDateEnabled(selected) && isSameMonth(selected, baseDate)) {\n    return selected;\n  }\n\n  var today = new Date();\n\n  if (isDateEnabled(today) && isSameMonth(today, baseDate)) {\n    return today;\n  }\n\n  if (isDateEnabled(baseDate)) {\n    return baseDate;\n  }\n\n  return null;\n}\nexport var Grids = function Grids(_a) {\n  var baseDate = _a.baseDate,\n      selectedStartDate = _a.selectedStartDate,\n      selectedEndDate = _a.selectedEndDate,\n      focusedDate = _a.focusedDate,\n      onFocusedDateChange = _a.onFocusedDateChange,\n      isDateEnabled = _a.isDateEnabled,\n      isSingleGrid = _a.isSingleGrid,\n      onSelectDate = _a.onSelectDate,\n      onChangeMonth = _a.onChangeMonth,\n      handleFocusMove = _a.handleFocusMove,\n      locale = _a.locale,\n      startOfWeek = _a.startOfWeek,\n      todayAriaLabel = _a.todayAriaLabel;\n  var containerRef = useRef(null);\n\n  var _b = useState(false),\n      gridHasFocus = _b[0],\n      setGridHasFocus = _b[1];\n\n  var focusedDateRef = useRef(null);\n  var baseDateTime = baseDate === null || baseDate === void 0 ? void 0 : baseDate.getTime();\n  var focusedDateTime = focusedDate === null || focusedDate === void 0 ? void 0 : focusedDate.getTime();\n  useEffect(function () {\n    if (focusedDate && !isVisible(focusedDate, baseDate, isSingleGrid)) {\n      // The nearestBaseDate depends on the direction of the month change\n      var direction = isAfter(focusedDate, baseDate) ? 'backwards' : 'forwards';\n      var newMonth = !isSingleGrid && direction === 'backwards' ? addMonths(baseDate, -1) : baseDate;\n      var nearestBaseDate = getBaseDate(newMonth, direction === 'backwards' ? -1 : 1, isDateEnabled);\n      var newFocusedDate = selectFocusedDate(focusedDate, nearestBaseDate, isDateEnabled);\n      onFocusedDateChange(newFocusedDate);\n    } // `baseDateTime` and `focusedDateTime` are used as more stable replacements for baseDate and focusedDate\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [focusedDateTime, baseDateTime, isSingleGrid, isDateEnabled, onFocusedDateChange]);\n\n  var onGridKeyDownHandler = function onGridKeyDownHandler(e) {\n    var updatedFocusDate;\n\n    if (focusedDate === null) {\n      return;\n    }\n\n    switch (e.keyCode) {\n      case KeyCode.enter:\n        e.preventDefault();\n\n        if (focusedDate) {\n          onSelectDate(focusedDate);\n        }\n\n        return;\n\n      case KeyCode.right:\n        e.preventDefault();\n        updatedFocusDate = handleFocusMove(focusedDate, isDateEnabled, function (date) {\n          return addDays(date, 1);\n        });\n        break;\n\n      case KeyCode.left:\n        e.preventDefault();\n        updatedFocusDate = handleFocusMove(focusedDate, isDateEnabled, function (date) {\n          return addDays(date, -1);\n        });\n        break;\n\n      case KeyCode.up:\n        e.preventDefault();\n        updatedFocusDate = handleFocusMove(focusedDate, isDateEnabled, function (date) {\n          return addWeeks(date, -1);\n        });\n        break;\n\n      case KeyCode.down:\n        e.preventDefault();\n        updatedFocusDate = handleFocusMove(focusedDate, isDateEnabled, function (date) {\n          return addWeeks(date, 1);\n        });\n        break;\n\n      default:\n        return;\n    }\n\n    var updatedDateIsVisible = isVisible(updatedFocusDate, baseDate, isSingleGrid);\n\n    if (!updatedDateIsVisible) {\n      var newMonthIsOnLeftSide = !isSingleGrid && isBefore(updatedFocusDate, baseDate);\n      onChangeMonth(newMonthIsOnLeftSide ? addMonths(updatedFocusDate, 1) : updatedFocusDate);\n    }\n\n    onFocusedDateChange(updatedFocusDate);\n  };\n\n  useEffect(function () {\n    // focus current date if the focus is already inside the calendar\n    if (focusedDate !== null && gridHasFocus) {\n      if (focusedDateRef.current && focusedDateRef.current !== document.activeElement) {\n        focusedDateRef.current.focus();\n      }\n    } // `focusedDateTime` is used as a more stable replacement for focusedDate\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [focusedDateTime, gridHasFocus]);\n\n  var onGridBlur = function onGridBlur(event) {\n    var _a;\n    /*\n     IE11 does not support event.relatedTarget, but sets document.activeElement to the newly\n     focused element before the onBlur handler is called.\n          However, other browsers do not make any guarantees for the value of document.activeElement\n     during the execution of an onBlur handler. Therefore, we have to use event.relatedTarget\n     instead.\n     */\n\n\n    var newFocusTarget = event.relatedTarget || document.activeElement;\n    var newFocusTargetIsInGrid = (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.contains(newFocusTarget);\n\n    if (newFocusTarget && !newFocusTargetIsInGrid && gridHasFocus) {\n      setGridHasFocus(false);\n    }\n  };\n\n  var onGridFocus = function onGridFocus() {\n    if (!gridHasFocus) {\n      setGridHasFocus(true);\n    }\n  };\n\n  var focusVisible = useFocusVisible();\n  var isRangeVisible = selectedStartDate && selectedEndDate || gridHasFocus && !!focusVisible['data-awsui-focus-visible'];\n  var rangeEnds = [selectedStartDate !== null && selectedStartDate !== void 0 ? selectedStartDate : focusedDate, selectedEndDate !== null && selectedEndDate !== void 0 ? selectedEndDate : focusedDate].filter(hasValue);\n  var rangeStartDate = min(rangeEnds);\n  var rangeEndDate = max(rangeEnds);\n  return React.createElement(\"div\", {\n    ref: containerRef,\n    onFocus: onGridFocus,\n    onBlur: onGridBlur\n  }, React.createElement(InternalSpaceBetween, {\n    size: \"xs\",\n    direction: \"horizontal\"\n  }, !isSingleGrid && React.createElement(Grid, {\n    className: styles['first-grid'],\n    baseDate: addMonths(baseDate, -1),\n    selectedEndDate: selectedEndDate,\n    selectedStartDate: selectedStartDate,\n    rangeStartDate: isRangeVisible ? rangeStartDate : null,\n    rangeEndDate: isRangeVisible ? rangeEndDate : null,\n    focusedDate: focusedDate,\n    focusedDateRef: focusedDateRef,\n    isDateEnabled: isDateEnabled,\n    onSelectDate: onSelectDate,\n    onGridKeyDownHandler: onGridKeyDownHandler,\n    onFocusedDateChange: onFocusedDateChange,\n    locale: locale,\n    startOfWeek: startOfWeek,\n    todayAriaLabel: todayAriaLabel\n  }), React.createElement(Grid, {\n    className: styles['second-grid'],\n    baseDate: baseDate,\n    selectedEndDate: selectedEndDate,\n    selectedStartDate: selectedStartDate,\n    rangeStartDate: isRangeVisible ? rangeStartDate : null,\n    rangeEndDate: isRangeVisible ? rangeEndDate : null,\n    focusedDate: focusedDate,\n    focusedDateRef: focusedDateRef,\n    isDateEnabled: isDateEnabled,\n    onSelectDate: onSelectDate,\n    onGridKeyDownHandler: onGridKeyDownHandler,\n    onFocusedDateChange: onFocusedDateChange,\n    locale: locale,\n    startOfWeek: startOfWeek,\n    todayAriaLabel: todayAriaLabel\n  })));\n};","map":null,"metadata":{},"sourceType":"module"}