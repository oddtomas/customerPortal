{"ast":null,"code":"import { __spreadArray } from \"tslib\";\nimport { fireNonCancelableEvent } from '../internal/events';\nexport var getQueryActions = function getQueryActions(query, onChange, inputRef, preventFocus) {\n  var tokens = query.tokens,\n      operation = query.operation;\n\n  var fireOnChange = function fireOnChange(tokens, operation) {\n    return fireNonCancelableEvent(onChange, {\n      tokens: tokens,\n      operation: operation\n    });\n  };\n\n  var setToken = function setToken(index, newToken) {\n    var newTokens = __spreadArray([], tokens, true);\n\n    if (newTokens && index < newTokens.length) {\n      newTokens[index] = newToken;\n    }\n\n    fireOnChange(newTokens, operation);\n  };\n\n  var removeToken = function removeToken(index) {\n    var _a;\n\n    var newTokens = tokens.filter(function (_, i) {\n      return i !== index;\n    });\n    fireOnChange(newTokens, operation);\n    preventFocus.current = true;\n    (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n  };\n\n  var removeAllTokens = function removeAllTokens() {\n    var _a;\n\n    fireOnChange([], operation);\n    preventFocus.current = true;\n    (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n  };\n\n  var addToken = function addToken(newToken) {\n    var newTokens = __spreadArray([], tokens, true);\n\n    newTokens.push(newToken);\n    fireOnChange(newTokens, operation);\n  };\n\n  var setOperation = function setOperation(newOperation) {\n    fireOnChange(tokens, newOperation);\n  };\n\n  return {\n    setToken: setToken,\n    removeToken: removeToken,\n    removeAllTokens: removeAllTokens,\n    addToken: addToken,\n    setOperation: setOperation\n  };\n};\nexport var getAllowedOperators = function getAllowedOperators(property) {\n  var _a;\n\n  var operators = property.operators,\n      defaultOperator = property.defaultOperator;\n  var operatorOrder = ['=', '!=', ':', '!:', '>=', '<=', '<', '>'];\n  var operatorSet = (_a = {}, _a[defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='] = true, _a);\n  operators === null || operators === void 0 ? void 0 : operators.forEach(function (op) {\n    return operatorSet[op] = true;\n  });\n  return operatorOrder.filter(function (op) {\n    return operatorSet[op];\n  });\n};\n/*\n * parses the value of the filtering input to figure out the current step of entering the token:\n * - \"property\": means that a filter on a particular column is being added, with operator already finalized\n * - \"operator\": means that a filter on a particular column is being added, with operator not yet finalized\n * - \"free-text\": means that a \"free text\" token is being added\n */\n\nexport var parseText = function parseText(filteringText, filteringProperties, disableFreeTextFiltering) {\n  var negatedGlobalQuery = /^(!:|!)(.*)/.exec(filteringText);\n\n  if (!disableFreeTextFiltering && negatedGlobalQuery) {\n    return {\n      step: 'free-text',\n      operator: '!:',\n      value: negatedGlobalQuery[2]\n    };\n  }\n\n  var property = (filteringProperties === null || filteringProperties === void 0 ? void 0 : filteringProperties.reduce(function (acc, property) {\n    if (filteringText.toLowerCase().indexOf(property.propertyLabel.toLowerCase()) === 0) {\n      // find the longest property whose name matches the filtering text\n      if (property.propertyLabel.length > acc.length) {\n        acc.length = property.propertyLabel.length;\n        acc.property = property;\n      }\n    }\n\n    return acc;\n  }, {\n    length: 0\n  })).property;\n\n  if (!property) {\n    return {\n      step: 'free-text',\n      value: filteringText\n    };\n  }\n\n  var allowedOps = getAllowedOperators(property);\n  var textWithoutProperty = filteringText.substring(property.propertyLabel.length);\n  var hasOperator = new RegExp(\"^(\\\\s*)(\".concat(allowedOps.join('|'), \")(.*)\")).exec(textWithoutProperty);\n\n  if (hasOperator) {\n    return {\n      step: 'property',\n      property: property,\n      // regex above can't match anything but an operator in the second capturing group\n      operator: hasOperator[2],\n      value: hasOperator[3].charAt(0) === ' ' ? hasOperator[3].slice(1) : hasOperator[3]\n    };\n  }\n\n  var opPrefixesMap = allowedOps.reduce(function (acc, op) {\n    if (op.length > 1) {\n      var substr = op.substring(0, 1);\n      acc[substr] = true;\n    }\n\n    return acc;\n  }, {});\n  var opPrefixes = Object.keys(opPrefixesMap);\n  var enteringOperator = new RegExp(\"^(\\\\s*)([\".concat(opPrefixes.join(','), \"])?$\")).exec(textWithoutProperty);\n\n  if (enteringOperator) {\n    return {\n      step: 'operator',\n      property: property,\n      operatorPrefix: enteringOperator[2] || ''\n    };\n  }\n\n  return {\n    step: 'free-text',\n    value: filteringText\n  };\n};\nexport var getPropertyOptions = function getPropertyOptions(filteringProperty, filteringOptions) {\n  return filteringOptions === null || filteringOptions === void 0 ? void 0 : filteringOptions.filter(function (option) {\n    return option.propertyKey === filteringProperty.key;\n  });\n};\nexport var getAllValueSuggestions = function getAllValueSuggestions(filteringOptions, filteringProperties, operator, i18nStrings, customGroupsText) {\n  if (operator === void 0) {\n    operator = '=';\n  }\n\n  var defaultGroup = {\n    label: i18nStrings.groupValuesText,\n    options: []\n  };\n  var customGroups = {};\n  filteringOptions === null || filteringOptions === void 0 ? void 0 : filteringOptions.forEach(function (filteringOption) {\n    var property = getPropertyByKey(filteringProperties, filteringOption.propertyKey); // given option refers to a non-existent filtering property\n\n    if (!property) {\n      return;\n    } // this option's filtering property does not support current operator\n\n\n    if (getAllowedOperators(property).indexOf(operator) === -1) {\n      return;\n    }\n\n    if (property.group && !customGroups[property.group]) {\n      var label = (customGroupsText === null || customGroupsText === void 0 ? void 0 : customGroupsText.reduce(function (acc, customGroup) {\n        return customGroup.group === property.group ? customGroup.values : acc;\n      }, '')) || '';\n      customGroups[property.group] = {\n        label: label,\n        options: []\n      };\n    }\n\n    var propertyGroup = property.group ? customGroups[property.group] : defaultGroup;\n    propertyGroup.options.push({\n      tokenValue: property.propertyLabel + (operator || '=') + filteringOption.value,\n      label: filteringOption.value,\n      __labelPrefix: property.propertyLabel + ' ' + (operator || '=')\n    });\n  });\n  return __spreadArray([defaultGroup], Object.keys(customGroups).map(function (group) {\n    return customGroups[group];\n  }), true);\n};\nexport var getPropertyByKey = function getPropertyByKey(filteringProperties, key) {\n  var propertyMap = filteringProperties.reduce(function (acc, property) {\n    acc[property.key] = property;\n    return acc;\n  }, {});\n  return propertyMap[key];\n};\n\nvar filteringPropertyToAutosuggestOption = function filteringPropertyToAutosuggestOption(filteringProperty) {\n  return {\n    value: filteringProperty.propertyLabel,\n    keepOpenOnSelect: true\n  };\n};\n\nexport function getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToOption) {\n  var defaultGroup = {\n    label: i18nStrings.groupPropertiesText,\n    options: []\n  };\n  var customGroups = {};\n  filteringProperties.forEach(function (filteringProperty) {\n    var group = filteringProperty.group;\n    var optionsGroup = defaultGroup;\n\n    if (group) {\n      if (!customGroups[group]) {\n        var label = (customGroupsText === null || customGroupsText === void 0 ? void 0 : customGroupsText.reduce(function (acc, customGroup) {\n          return customGroup.group === group ? customGroup.properties : acc;\n        }, '')) || '';\n        customGroups[group] = {\n          options: [],\n          label: label\n        };\n      }\n\n      optionsGroup = customGroups[group];\n    }\n\n    optionsGroup.options.push(filteringPropertyToOption(filteringProperty));\n  });\n  var defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];\n  var customGroupsArray = Object.keys(customGroups).map(function (groupKey) {\n    return customGroups[groupKey];\n  });\n  return __spreadArray(__spreadArray([], defaultGroupArray, true), customGroupsArray, true);\n}\nexport var getAutosuggestOptions = function getAutosuggestOptions(parsedText, filteringOptions, filteringProperties, customGroupsText, i18nStrings) {\n  switch (parsedText.step) {\n    case 'property':\n      {\n        var _a = parsedText.property,\n            propertyLabel_1 = _a.propertyLabel,\n            groupValuesLabel = _a.groupValuesLabel;\n        var options = getPropertyOptions(parsedText.property, filteringOptions);\n        return {\n          __filterText: parsedText.value,\n          options: [{\n            options: (options || []).map(function (_a) {\n              var value = _a.value;\n              return {\n                tokenValue: propertyLabel_1 + parsedText.operator + value,\n                label: value,\n                __labelPrefix: propertyLabel_1 + ' ' + parsedText.operator\n              };\n            }),\n            label: groupValuesLabel\n          }]\n        };\n      }\n\n    case 'operator':\n      {\n        return {\n          __filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,\n          options: __spreadArray(__spreadArray([], getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption), true), [{\n            options: getAllowedOperators(parsedText.property).map(function (value) {\n              return {\n                value: parsedText.property.propertyLabel + ' ' + value + ' ',\n                label: parsedText.property.propertyLabel + ' ' + value,\n                description: operatorToDescription(value, i18nStrings),\n                keepOpenOnSelect: true\n              };\n            }),\n            label: i18nStrings.operatorsText\n          }], false)\n        };\n      }\n\n    case 'free-text':\n      {\n        var needsValueSuggestions = !!parsedText.value;\n        var needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');\n        return {\n          __filterText: parsedText.value,\n          options: __spreadArray(__spreadArray([], needsPropertySuggestions ? getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption) : [], true), needsValueSuggestions ? getAllValueSuggestions(filteringOptions, filteringProperties, parsedText.operator, i18nStrings, customGroupsText) : [], true)\n        };\n      }\n  }\n};\nexport var operatorToDescription = function operatorToDescription(operator, i18nStrings) {\n  var _a;\n\n  var mapping = (_a = {}, _a['<'] = i18nStrings.operatorLessText, _a['<='] = i18nStrings.operatorLessOrEqualText, _a['>'] = i18nStrings.operatorGreaterText, _a['>='] = i18nStrings.operatorGreaterOrEqualText, _a[':'] = i18nStrings.operatorContainsText, _a['!:'] = i18nStrings.operatorDoesNotContainText, _a['='] = i18nStrings.operatorEqualsText, _a['!='] = i18nStrings.operatorDoesNotEqualText, _a);\n  return mapping[operator];\n};","map":null,"metadata":{},"sourceType":"module"}