{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useRef } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { filterOptions, isInteractive, isGroupInteractive, isGroup } from '../../internal/components/option/utils/filter-options';\nimport { useDebounceCallback } from '../../internal/hooks/use-debounce-callback';\nexport var isChar = function isChar(keyCode) {\n  return [0, KeyCode.enter, KeyCode.space, KeyCode.tab].indexOf(keyCode) === -1;\n};\nexport var isRepeatedChar = function isRepeatedChar(str) {\n  return str.split('').every(function (c) {\n    return c === str[0];\n  });\n};\n\nfunction findMatchingOption(options, searchText, currentHighlight, useInteractiveGroups) {\n  var interactivityCheck = useInteractiveGroups ? isGroupInteractive : isInteractive;\n\n  var filter = function filter(searchText) {\n    return filterOptions(options, searchText, true).filter(function (option) {\n      return interactivityCheck(option);\n    });\n  };\n\n  var matchingOptions = filter(searchText);\n\n  if (matchingOptions.length === 1) {\n    return matchingOptions[0];\n  } // Hit the same char over and over, we assume they want to cycle through\n\n\n  if (currentHighlight && searchText.length > 1 && isRepeatedChar(searchText)) {\n    var matchingOptions_1 = filter(searchText[0]);\n\n    if (matchingOptions_1.length > 0) {\n      //handling OptionGroups when useInteractiveGroups is set\n      var active = isGroup(currentHighlight) ? matchingOptions_1.map(function (_a) {\n        var option = _a.option;\n        return option;\n      }).indexOf(currentHighlight) : matchingOptions_1.map(function (_a) {\n        var option = _a.option;\n        return option.value;\n      }).indexOf(currentHighlight.value); // Pick the next thing (if something with this prefix wasn't selected\n      // we'll end up with the first option)\n\n      active += 1;\n      active = active % matchingOptions_1.length;\n      return matchingOptions_1[active];\n    }\n  } // We have multiple things that start with this prefix.  Based on the\n  // behavior of native select, this is considered after the repeated case\n\n\n  if (matchingOptions.length > 0) {\n    return matchingOptions[0];\n  }\n\n  return null;\n}\n\nexport function useNativeSearch(_a) {\n  var isEnabled = _a.isEnabled,\n      options = _a.options,\n      isKeyboard = _a.isKeyboard,\n      highlightOption = _a.highlightOption,\n      highlightedOption = _a.highlightedOption,\n      useInteractiveGroups = _a.useInteractiveGroups;\n  var value = useRef('');\n  var delayedResetValue = useDebounceCallback(function () {\n    return value.current = '';\n  }, 500);\n  return function (event) {\n    isKeyboard.current = true;\n\n    if (!isEnabled) {\n      return;\n    }\n\n    var charCode = event.charCode;\n\n    if (!isChar(charCode)) {\n      return;\n    }\n\n    delayedResetValue();\n    var newValue = value.current + String.fromCharCode(charCode);\n    value.current = newValue;\n    var nextHighlight = findMatchingOption(options, newValue, highlightedOption, useInteractiveGroups);\n\n    if (nextHighlight) {\n      highlightOption(nextHighlight);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}