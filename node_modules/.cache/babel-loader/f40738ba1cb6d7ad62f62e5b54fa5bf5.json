{"ast":null,"code":"import { __assign, __rest } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport clsx from 'clsx';\nimport React, { useCallback, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { getBaseProps } from '../internal/base-component';\nimport { useControllable } from '../internal/hooks/use-controllable';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { applyDefaults } from './defaults';\nimport { Notifications } from './notifications';\nimport { MobileToolbar } from './mobile-toolbar';\nimport { SplitPanelWrapper } from './split-panel-wrapper';\nimport { useFocusControl } from './utils/use-focus-control';\nimport useWindowWidth from './utils/use-window-width';\nimport useContentHeight from './utils/use-content-height';\nimport styles from './styles.css.js';\nimport testutilStyles from './test-classes/styles.css.js';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { AppLayoutContext } from '../internal/context/app-layout-context';\nimport { useContainerQuery } from '../internal/hooks/container-queries';\nimport { useStableEventHandler } from '../internal/hooks/use-stable-event-handler';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport { CONSTRAINED_MAIN_PANEL_MIN_HEIGHT, CONSTRAINED_PAGE_HEIGHT, getSplitPanelDefaultSize, MAIN_PANEL_MIN_HEIGHT } from '../split-panel/utils/size-utils';\nimport useBaseComponent from '../internal/hooks/use-base-component';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport ContentWrapper from './content-wrapper';\nimport { DarkHeader } from './dark-header';\nimport { isMotionDisabled } from '../internal/motion';\nimport { useEffectOnUpdate } from '../internal/hooks/use-effect-on-update';\nimport { NavigationPanel } from './navigation-panel';\nimport { ToolsAndSplitPanel } from './tools-and-split-panel';\nimport { usePreviousFrameValue } from '../internal/hooks/use-previous-frame';\nimport useAppLayoutOffsets from './utils/use-content-width';\nimport { isDevelopment } from '../internal/is-development';\nimport { warnOnce } from '../internal/logging';\nimport RefreshedAppLayout from './visual-refresh';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nvar AppLayout = React.forwardRef(function (_a, ref) {\n  var _b = _a.contentType,\n      contentType = _b === void 0 ? 'default' : _b,\n      _c = _a.headerSelector,\n      headerSelector = _c === void 0 ? '#b #h' : _c,\n      _d = _a.footerSelector,\n      footerSelector = _d === void 0 ? '#b #f' : _d,\n      rest = __rest(_a, [\"contentType\", \"headerSelector\", \"footerSelector\"]);\n\n  var __internalRootRef = useBaseComponent('AppLayout').__internalRootRef;\n\n  var isRefresh = useVisualRefresh(__internalRootRef); // This re-builds the props including the default values\n\n  var props = __assign({\n    contentType: contentType,\n    headerSelector: headerSelector,\n    footerSelector: footerSelector\n  }, rest);\n\n  var baseProps = getBaseProps(rest);\n  return React.createElement(\"div\", __assign({\n    ref: __internalRootRef\n  }, baseProps), isRefresh ? React.createElement(RefreshedAppLayout, __assign({}, props, {\n    ref: ref\n  })) : React.createElement(OldAppLayout, __assign({}, props, {\n    ref: ref\n  })));\n});\nvar OldAppLayout = React.forwardRef(function (_a, ref) {\n  var _b;\n\n  var _c;\n\n  var navigation = _a.navigation,\n      _d = _a.navigationWidth,\n      navigationWidth = _d === void 0 ? 280 : _d,\n      navigationHide = _a.navigationHide,\n      controlledNavigationOpen = _a.navigationOpen,\n      tools = _a.tools,\n      _e = _a.toolsWidth,\n      toolsWidth = _e === void 0 ? 290 : _e,\n      toolsHide = _a.toolsHide,\n      controlledToolsOpen = _a.toolsOpen,\n      breadcrumbs = _a.breadcrumbs,\n      notifications = _a.notifications,\n      stickyNotifications = _a.stickyNotifications,\n      contentHeader = _a.contentHeader,\n      disableContentHeaderOverlap = _a.disableContentHeaderOverlap,\n      content = _a.content,\n      _f = _a.contentType,\n      contentType = _f === void 0 ? 'default' : _f,\n      disableContentPaddings = _a.disableContentPaddings,\n      disableBodyScroll = _a.disableBodyScroll,\n      maxContentWidth = _a.maxContentWidth,\n      minContentWidth = _a.minContentWidth,\n      _g = _a.headerSelector,\n      headerSelector = _g === void 0 ? '#b #h' : _g,\n      _h = _a.footerSelector,\n      footerSelector = _h === void 0 ? '#b #f' : _h,\n      ariaLabels = _a.ariaLabels,\n      splitPanel = _a.splitPanel,\n      controlledSplitPanelSize = _a.splitPanelSize,\n      controlledSplitPanelOpen = _a.splitPanelOpen,\n      controlledSplitPanelPreferences = _a.splitPanelPreferences,\n      onSplitPanelPreferencesChange = _a.onSplitPanelPreferencesChange,\n      onSplitPanelResize = _a.onSplitPanelResize,\n      onSplitPanelToggle = _a.onSplitPanelToggle,\n      onNavigationChange = _a.onNavigationChange,\n      onToolsChange = _a.onToolsChange;\n\n  if (isDevelopment) {\n    if (controlledToolsOpen && toolsHide) {\n      warnOnce('AppLayout', \"You have enabled both the `toolsOpen` prop and the `toolsHide` prop. This is not supported. Set `toolsOpen` to `false` when you set `toolsHide` to `true`.\");\n    }\n  }\n\n  var rootRef = useRef(null);\n  var isMobile = useMobile();\n  var isMotionEnabled = rootRef.current ? !isMotionDisabled(rootRef.current) : false;\n  var defaults = applyDefaults(contentType, {\n    maxContentWidth: maxContentWidth,\n    minContentWidth: minContentWidth\n  }, false);\n  var darkStickyHeaderContentType = ['cards', 'table'].indexOf(contentType) > -1;\n\n  var _j = useControllable(controlledNavigationOpen, onNavigationChange, isMobile ? false : defaults.navigationOpen, {\n    componentName: 'AppLayout',\n    controlledProp: 'navigationOpen',\n    changeHandler: 'onNavigationChange'\n  }),\n      _k = _j[0],\n      navigationOpen = _k === void 0 ? false : _k,\n      setNavigationOpen = _j[1];\n\n  var _l = useControllable(controlledToolsOpen, onToolsChange, isMobile ? false : defaults.toolsOpen, {\n    componentName: 'AppLayout',\n    controlledProp: 'toolsOpen',\n    changeHandler: 'onToolsChange'\n  }),\n      _m = _l[0],\n      toolsOpen = _m === void 0 ? false : _m,\n      setToolsOpen = _l[1];\n\n  var onNavigationToggle = useCallback(function (open) {\n    setNavigationOpen(open);\n    fireNonCancelableEvent(onNavigationChange, {\n      open: open\n    });\n  }, [setNavigationOpen, onNavigationChange]);\n  var onToolsToggle = useCallback(function (open) {\n    setToolsOpen(open);\n    fireNonCancelableEvent(onToolsChange, {\n      open: open\n    });\n  }, [setToolsOpen, onToolsChange]);\n\n  var onNavigationClick = function onNavigationClick(event) {\n    var hasLink = findUpUntil(event.target, function (node) {\n      return node.tagName === 'A' && !!node.href;\n    });\n\n    if (hasLink) {\n      onNavigationToggle(false);\n    }\n  };\n\n  var navigationVisible = !navigationHide && navigationOpen;\n  var toolsVisible = !toolsHide && toolsOpen;\n\n  var _o = useContentHeight(headerSelector, footerSelector, disableBodyScroll),\n      contentHeightStyle = _o.contentHeightStyle,\n      headerHeight = _o.headerHeight,\n      footerHeight = _o.footerHeight,\n      panelHeightStyle = _o.panelHeightStyle;\n\n  var _p = useContainerQuery(function (rect) {\n    return rect.height;\n  }),\n      notificationsHeight = _p[0],\n      notificationsRef = _p[1];\n\n  var _q = useContainerQuery(function (rect) {\n    return splitPanel ? rect.height : 0;\n  }, [splitPanel]),\n      splitPanelHeight = _q[0],\n      splitPanelRef = _q[1];\n\n  var _r = useContainerQuery(function (rect) {\n    return splitPanel ? rect.height : 0;\n  }, [splitPanel]),\n      splitPanelHeaderHeight = _r[0],\n      splitPanelHeaderMeasureRef = _r[1];\n\n  var splitPanelHeaderRefObject = useRef(null);\n  var splitPanelHeaderRef = useMergeRefs(splitPanelHeaderMeasureRef, splitPanelHeaderRefObject);\n  var anyPanelOpen = navigationVisible || toolsVisible;\n  var hasRenderedNotifications = notificationsHeight ? notificationsHeight > 0 : false;\n  var stickyNotificationsHeight = stickyNotifications ? notificationsHeight : null;\n\n  var _s = useControllable(controlledSplitPanelPreferences, onSplitPanelPreferencesChange, undefined, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelPreferences',\n    changeHandler: 'onSplitPanelPreferencesChange'\n  }),\n      splitPanelPreferences = _s[0],\n      setSplitPanelPreferences = _s[1];\n\n  var splitPanelPosition = (splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position) || 'bottom';\n  var closedDrawerWidth = 40;\n  var effectiveNavigationWidth = navigationHide ? 0 : navigationOpen ? navigationWidth : closedDrawerWidth;\n  var effectiveToolsWidth = toolsHide && (!splitPanel || (splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position) !== 'side') ? 0 : toolsOpen ? toolsWidth : closedDrawerWidth;\n  var defaultSplitPanelSize = getSplitPanelDefaultSize(splitPanelPosition);\n\n  var _t = useControllable(controlledSplitPanelSize, onSplitPanelResize, defaultSplitPanelSize, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelSize',\n    changeHandler: 'onSplitPanelResize'\n  }),\n      _u = _t[0],\n      splitPanelSize = _u === void 0 ? defaultSplitPanelSize : _u,\n      setSplitPanelSize = _t[1];\n\n  var _v = useControllable(controlledSplitPanelOpen, onSplitPanelToggle, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelOpen',\n    changeHandler: 'onSplitPanelToggle'\n  }),\n      _w = _v[0],\n      splitPanelOpen = _w === void 0 ? false : _w,\n      setSplitPanelOpen = _v[1];\n\n  var mainContentRef = useRef(null);\n  var legacyScrollRootRef = useRef(null);\n  var onSplitPanelPreferencesSet = useCallback(function (detail) {\n    setSplitPanelPreferences(detail);\n    fireNonCancelableEvent(onSplitPanelPreferencesChange, detail);\n  }, [setSplitPanelPreferences, onSplitPanelPreferencesChange]);\n  var onSplitPanelSizeSet = useCallback(function (detail) {\n    setSplitPanelSize(detail.size);\n    fireNonCancelableEvent(onSplitPanelResize, detail);\n  }, [setSplitPanelSize, onSplitPanelResize]);\n  var onToggle = useCallback(function () {\n    setSplitPanelOpen(!splitPanelOpen);\n    fireNonCancelableEvent(onSplitPanelToggle, {\n      open: !splitPanelOpen\n    });\n  }, [setSplitPanelOpen, splitPanelOpen, onSplitPanelToggle]);\n  var getSplitPanelMaxWidth = useStableEventHandler(function () {\n    if (!mainContentRef.current || !defaults.minContentWidth) {\n      return NaN;\n    }\n\n    var width = parseInt(getComputedStyle(mainContentRef.current).width); // when disableContentPaddings is true there is less available space,\n    // so we subtract space-scaled-2x-xxxl * 2 for left and right padding\n\n    var contentPadding = disableContentPaddings ? 80 : 0;\n    var spaceAvailable = width - defaults.minContentWidth - contentPadding;\n    var spaceTaken = finalSplitPanePosition === 'side' ? splitPanelSize : 0;\n    return Math.max(0, spaceTaken + spaceAvailable);\n  });\n  var getSplitPanelMaxHeight = useStableEventHandler(function () {\n    if (typeof document === 'undefined') {\n      return 0; // render the split panel in its minimum possible size\n    } else if (disableBodyScroll && legacyScrollRootRef.current) {\n      var availableHeight = legacyScrollRootRef.current.clientHeight;\n      return availableHeight < CONSTRAINED_PAGE_HEIGHT ? availableHeight : availableHeight - MAIN_PANEL_MIN_HEIGHT;\n    } else {\n      var availableHeight = document.documentElement.clientHeight - headerHeight - footerHeight;\n      return availableHeight < CONSTRAINED_PAGE_HEIGHT ? availableHeight - CONSTRAINED_MAIN_PANEL_MIN_HEIGHT : availableHeight - MAIN_PANEL_MIN_HEIGHT;\n    }\n  });\n\n  var _x = useState(false),\n      isForcedPosition = _x[0],\n      setIsForcedPosition = _x[1];\n\n  var finalSplitPanePosition = isForcedPosition ? 'bottom' : splitPanelPosition;\n  var splitPaneAvailableOnTheSide = Boolean(splitPanel) && finalSplitPanePosition === 'side';\n  var splitPanelOpenOnTheSide = splitPaneAvailableOnTheSide && splitPanelOpen;\n  var toggleButtonsBarWidth = 0;\n  var windowWidth = useWindowWidth();\n\n  var _y = useAppLayoutOffsets(rootRef.current),\n      leftOffset = _y.left,\n      rightOffset = _y.right;\n\n  var contentWidthWithSplitPanel = windowWidth - leftOffset - rightOffset - effectiveToolsWidth - effectiveNavigationWidth - (disableContentPaddings ? 0 : toggleButtonsBarWidth);\n  useEffect(function () {\n    var contentWidth = contentWidthWithSplitPanel - splitPanelSize;\n    setIsForcedPosition(isMobile || (defaults.minContentWidth || 0) > contentWidth); // This is a workaround to avoid a forced position due to splitPanelSize, which is\n    // user controlled variable.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [contentWidthWithSplitPanel, defaults.minContentWidth, isMobile]);\n  var navigationClosedWidth = navigationHide || isMobile ? 0 : closedDrawerWidth;\n  var toolsClosedWidth = toolsHide || isMobile ? 0 : closedDrawerWidth;\n\n  var _z = useState(),\n      splitPanelLastInteraction = _z[0],\n      setSplitPanelLastInteraction = _z[1];\n\n  useEffectOnUpdate(function () {\n    return setSplitPanelLastInteraction(splitPanelOpen ? {\n      type: 'open'\n    } : {\n      type: 'close'\n    });\n  }, [splitPanelOpen]);\n  useEffectOnUpdate(function () {\n    return setSplitPanelLastInteraction({\n      type: 'position'\n    });\n  }, [splitPanelPosition]);\n  var contentMaxWidthStyle = !isMobile ? {\n    maxWidth: defaults.maxContentWidth\n  } : undefined;\n\n  var _0 = useState(0),\n      splitPanelReportedSize = _0[0],\n      setSplitPanelReportedSize = _0[1];\n\n  var splitPanelContext = {\n    topOffset: headerHeight + (finalSplitPanePosition === 'bottom' ? stickyNotificationsHeight || 0 : 0),\n    bottomOffset: footerHeight,\n    leftOffset: leftOffset + (isMobile ? 0 : !navigationHide && navigationOpen ? navigationWidth : navigationClosedWidth),\n    rightOffset: rightOffset + (isMobile ? 0 : !toolsHide && toolsOpen ? toolsWidth : toolsClosedWidth),\n    position: finalSplitPanePosition,\n    size: splitPanelSize,\n    getMaxWidth: getSplitPanelMaxWidth,\n    getMaxHeight: getSplitPanelMaxHeight,\n    getHeader: function getHeader() {\n      return splitPanelHeaderRefObject.current;\n    },\n    disableContentPaddings: disableContentPaddings,\n    contentWidthStyles: contentMaxWidthStyle,\n    isOpen: splitPanelOpen,\n    isMobile: isMobile,\n    isRefresh: false,\n    isForcedPosition: isForcedPosition,\n    lastInteraction: splitPanelLastInteraction,\n    splitPanelRef: splitPanelRef,\n    splitPanelHeaderRef: splitPanelHeaderRef,\n    onResize: onSplitPanelSizeSet,\n    onToggle: onToggle,\n    onPreferencesChange: onSplitPanelPreferencesSet,\n    reportSize: setSplitPanelReportedSize\n  };\n  var contentWrapperProps = {\n    navigationPadding: navigationHide || !!navigationOpen,\n    toolsPadding: // tools padding is displayed in one of the three cases\n    // 1. Nothing on the that screen edge (no tools panel and no split panel)\n    toolsHide && (!splitPanel || finalSplitPanePosition !== 'side') || // 2. Tools panel is present and open\n    toolsVisible || // 3. Split panel is open in side position\n    splitPanelOpenOnTheSide,\n    isMobile: isMobile\n  };\n  var navigationRefs = useFocusControl(navigationOpen);\n  var toolsRefs = useFocusControl(toolsOpen);\n  useImperativeHandle(ref, function () {\n    return {\n      openTools: function openTools() {\n        return onToolsToggle(true);\n      },\n      closeNavigationIfNecessary: function closeNavigationIfNecessary() {\n        if (isMobile) {\n          onNavigationToggle(false);\n        }\n      }\n    };\n  }, [isMobile, onNavigationToggle, onToolsToggle]);\n  var splitPanelBottomOffset = (_c = !splitPanel || finalSplitPanePosition !== 'bottom' ? undefined : splitPanelOpen ? splitPanelHeight : splitPanelHeaderHeight) !== null && _c !== void 0 ? _c : undefined;\n  var contentWidthStyles = !isMobile ? {\n    minWidth: defaults.minContentWidth,\n    maxWidth: defaults.maxContentWidth\n  } : undefined;\n  var isToolsDrawerHidden = disableContentPaddings;\n\n  var toolsDrawerWidth = function () {\n    if (isMobile) {\n      return 0;\n    }\n\n    var toolsPanelWidth = toolsHide ? 0 : toolsOpen ? toolsWidth : closedDrawerWidth;\n    var splitPanelWidth = !splitPanel || finalSplitPanePosition !== 'side' ? 0 : splitPanelOpen ? splitPanelReportedSize : closedDrawerWidth;\n    return toolsPanelWidth + splitPanelWidth;\n  }();\n\n  var navigationDrawerWidth = function () {\n    if (isMobile) {\n      return 0;\n    }\n\n    return effectiveNavigationWidth;\n  }();\n\n  var contentHeaderProps = {\n    isMobile: isMobile,\n    navigationWidth: effectiveNavigationWidth,\n    toolsWidth: disableContentPaddings ? 0 : toolsDrawerWidth ? toolsDrawerWidth : isToolsDrawerHidden ? toggleButtonsBarWidth : 0\n  };\n  var previousContentWidth = usePreviousFrameValue(contentWidthWithSplitPanel - (splitPanelOpenOnTheSide ? splitPanelReportedSize : 0));\n\n  var contentScaleX = function () {\n    if (isMobile || !isMotionEnabled || !disableContentPaddings || !previousContentWidth) {\n      return undefined;\n    }\n  }();\n\n  return React.createElement(\"div\", {\n    className: clsx(styles.root, testutilStyles.root, disableBodyScroll && styles['root-no-scroll']),\n    ref: rootRef\n  }, React.createElement(\"div\", {\n    className: styles['layout-wrapper'],\n    style: contentHeightStyle\n  }, isMobile && (!toolsHide || !navigationHide || breadcrumbs) && React.createElement(MobileToolbar, {\n    anyPanelOpen: anyPanelOpen,\n    toggleRefs: {\n      navigation: navigationRefs.toggle,\n      tools: toolsRefs.toggle\n    },\n    topOffset: headerHeight,\n    ariaLabels: ariaLabels,\n    navigationHide: navigationHide,\n    toolsHide: toolsHide,\n    onNavigationOpen: function onNavigationOpen() {\n      return onNavigationToggle(true);\n    },\n    onToolsOpen: function onToolsOpen() {\n      return onToolsToggle(true);\n    },\n    unfocusable: anyPanelOpen\n  }, breadcrumbs), React.createElement(\"div\", {\n    className: clsx(styles.layout, disableBodyScroll && styles['layout-no-scroll'])\n  }, !navigationHide && React.createElement(NavigationPanel, {\n    ariaLabels: ariaLabels,\n    footerHeight: footerHeight,\n    headerHeight: headerHeight,\n    isHidden: disableContentPaddings,\n    isMobile: isMobile,\n    isMotionEnabled: isMotionEnabled,\n    navigation: navigation,\n    navigationDrawerWidth: navigationDrawerWidth,\n    navigationOpen: navigationOpen,\n    onClick: isMobile ? onNavigationClick : undefined,\n    onNavigationToggle: onNavigationToggle,\n    panelHeightStyle: panelHeightStyle,\n    toggleRefs: navigationRefs,\n    navigationWidth: navigationWidth\n  }), React.createElement(\"main\", {\n    ref: legacyScrollRootRef,\n    className: clsx(styles['layout-main'], (_b = {}, _b[styles['layout-main-scrollable']] = disableBodyScroll, _b[testutilStyles['disable-body-scroll-root']] = disableBodyScroll, _b[styles.unfocusable] = isMobile && anyPanelOpen, _b))\n  }, React.createElement(\"div\", {\n    style: {\n      marginBottom: splitPanelBottomOffset,\n      transform: contentScaleX ? \"scaleX(\".concat(contentScaleX, \")\") : undefined\n    }\n  }, notifications && React.createElement(DarkHeader, __assign({}, contentHeaderProps, {\n    topOffset: disableBodyScroll ? 0 : headerHeight,\n    sticky: !isMobile && darkStickyHeaderContentType && stickyNotifications\n  }), React.createElement(Notifications, {\n    testUtilsClassName: clsx(styles.notifications, testutilStyles.notifications),\n    labels: ariaLabels,\n    topOffset: headerHeight,\n    sticky: !isMobile && stickyNotifications,\n    ref: notificationsRef,\n    isMobile: isMobile,\n    navigationPadding: contentWrapperProps.navigationPadding,\n    toolsPadding: contentWrapperProps.toolsPadding,\n    contentWidthStyles: contentWidthStyles\n  }, notifications)), (!isMobile && breadcrumbs || contentHeader) && React.createElement(DarkHeader, __assign({}, contentHeaderProps), React.createElement(ContentWrapper, __assign({}, contentWrapperProps, {\n    contentWidthStyles: contentWidthStyles\n  }), !isMobile && breadcrumbs && React.createElement(\"div\", {\n    className: clsx(styles.breadcrumbs, testutilStyles.breadcrumbs, styles['breadcrumbs-desktop'], darkStickyHeaderContentType && styles['breadcrumbs-desktop-sticky-header'])\n  }, breadcrumbs), contentHeader && React.createElement(\"div\", {\n    className: clsx(styles['content-header-wrapper'], !hasRenderedNotifications && (isMobile || !breadcrumbs) && styles['content-extra-top-padding'], !hasRenderedNotifications && !breadcrumbs && styles['content-header-wrapper-first-child'], !disableContentHeaderOverlap && styles['content-header-wrapper-overlapped'])\n  }, contentHeader))), React.createElement(ContentWrapper, __assign({}, contentWrapperProps, {\n    ref: mainContentRef,\n    disablePaddings: disableContentPaddings,\n    // eslint-disable-next-line react/forbid-component-props\n    className: clsx(!disableContentPaddings && styles['content-wrapper'], !disableContentPaddings && (isMobile || !breadcrumbs) && !contentHeader && styles['content-extra-top-padding'], !hasRenderedNotifications && !breadcrumbs && !isMobile && !contentHeader && styles['content-wrapper-first-child'])\n  }), React.createElement(\"div\", {\n    className: clsx(styles.content, testutilStyles.content, !disableContentHeaderOverlap && contentHeader && styles['content-overlapped']),\n    style: contentWidthStyles\n  }, React.createElement(AppLayoutContext.Provider, {\n    value: {\n      stickyOffsetTop: (disableBodyScroll ? 0 : headerHeight) + (stickyNotificationsHeight !== null ? stickyNotificationsHeight : 0),\n      stickyOffsetBottom: footerHeight + (splitPanelBottomOffset || 0)\n    }\n  }, content)))), finalSplitPanePosition === 'bottom' && React.createElement(SplitPanelWrapper, {\n    context: splitPanelContext\n  }, splitPanel)), React.createElement(ToolsAndSplitPanel, {\n    splitPanel: finalSplitPanePosition === 'side' ? splitPanel : undefined,\n    ariaLabels: ariaLabels,\n    closedDrawerWidth: closedDrawerWidth,\n    contentHeightStyle: contentHeightStyle,\n    disableContentPaddings: disableContentPaddings,\n    drawerWidth: toolsDrawerWidth,\n    footerHeight: footerHeight,\n    headerHeight: headerHeight,\n    isHidden: isToolsDrawerHidden,\n    isMobile: isMobile,\n    isMotionEnabled: isMotionEnabled,\n    onToolsToggle: onToolsToggle,\n    panelHeightStyle: panelHeightStyle,\n    splitPanelContext: splitPanelContext,\n    splitPanelOpen: splitPanelOpenOnTheSide,\n    splitPanelReportedSize: splitPanelReportedSize,\n    toggleRefs: toolsRefs,\n    tools: tools,\n    toolsHide: Boolean(toolsHide),\n    toolsOpen: toolsOpen,\n    toolsWidth: toolsWidth\n  }))));\n});\napplyDisplayName(AppLayout, 'AppLayout');\nexport default AppLayout;","map":null,"metadata":{},"sourceType":"module"}