{"ast":null,"code":"import { __assign } from \"tslib\";\nimport styles from './styles.css.js';\nexport var dimensionsBySize = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: 8,\n    padding: 8,\n    paddingLabels: 44\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: 12,\n    padding: 12,\n    paddingLabels: 44\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: 12,\n    padding: 12,\n    paddingLabels: 44\n  }\n};\nexport var refreshDimensionsBySize = {\n  small: __assign(__assign({}, dimensionsBySize.small), {\n    innerRadius: 38,\n    cornerRadius: 3\n  }),\n  medium: __assign(__assign({}, dimensionsBySize.medium), {\n    innerRadius: 75,\n    cornerRadius: 4\n  }),\n  large: __assign(__assign({}, dimensionsBySize.large), {\n    innerRadius: 105,\n    cornerRadius: 5\n  })\n};\nexport var defaultDetails = function defaultDetails(i18nStrings) {\n  return function (datum, dataSum) {\n    return [{\n      key: i18nStrings.detailsValue || '',\n      value: datum.value\n    }, {\n      key: i18nStrings.detailsPercentage || '',\n      value: \"\".concat((datum.value * 100 / dataSum).toFixed(0), \"%\")\n    }];\n  };\n};\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\n\nexport var balanceLabelNodes = function balanceLabelNodes(nodes, markers, leftSide) {\n  var _a;\n\n  var MARGIN = 10;\n  var previousBBox = null; // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n\n  var i = leftSide ? nodes.length - 1 : 0;\n\n  while (leftSide && i >= 0 || !leftSide && i < nodes.length) {\n    var node = nodes[i]; // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n\n    var x = parseFloat(node.getAttribute('data-x') || '0');\n    var y = parseFloat(node.getAttribute('data-y') || '0');\n    var box = {\n      x: x,\n      y: y,\n      height: node.getBoundingClientRect().height\n    };\n    var marker = markers[i];\n\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n\n    if (!leftSide && box.x < 0 || leftSide && box.x >= 0) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n\n    node.setAttribute('transform', ''); // Calculate how much the current node is overlapping with the previous one.\n\n    var offset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n\n    if (offset > 0) {\n      // Move the label down.\n      node.setAttribute('transform', \"translate(0 \".concat(offset, \")\")); // Adjust the attached line accordingly.\n\n      var lineNode = (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.querySelector(\".\".concat(styles['label-line']));\n\n      if (lineNode) {\n        var endY = marker.endY;\n        lineNode.setAttribute('y2', '' + (endY + offset));\n      } // Update the position accordingly to inform the next label\n\n\n      box.y += offset;\n    }\n\n    previousBBox = box;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}