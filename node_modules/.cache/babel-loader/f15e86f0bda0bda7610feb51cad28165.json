{"ast":null,"code":"import { __assign, __rest } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport clsx from 'clsx';\nimport React, { useImperativeHandle, useRef } from 'react';\nimport InternalContainer from '../container/internal';\nimport { getBaseProps } from '../internal/base-component';\nimport ToolsHeader from './tools-header';\nimport Thead from './thead';\nimport { TableBodyCell, TableBodyCellContent } from './body-cell';\nimport InternalStatusIndicator from '../status-indicator/internal';\nimport { useContainerQuery } from '../internal/hooks/container-queries';\nimport { supportsStickyPosition } from '../internal/utils/dom';\nimport SelectionControl from './selection-control';\nimport { checkSortingState, getColumnKey, getItemKey, toContainerVariant } from './utils';\nimport { useRowEvents } from './use-row-events';\nimport { focusMarkers, useFocusMove, useSelection } from './use-selection';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { isDevelopment } from '../internal/is-development';\nimport { checkColumnWidths, ColumnWidthsProvider, DEFAULT_WIDTH } from './use-column-widths';\nimport { useScrollSync } from '../internal/hooks/use-scroll-sync';\nimport { ResizeTracker } from './resizer';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport StickyHeader from './sticky-header';\nimport StickyScrollbar from './sticky-scrollbar';\nimport useFocusVisible from '../internal/hooks/focus-visible';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nvar InternalTable = React.forwardRef(function (_a, ref) {\n  var _b;\n\n  var header = _a.header,\n      footer = _a.footer,\n      empty = _a.empty,\n      filter = _a.filter,\n      pagination = _a.pagination,\n      preferences = _a.preferences,\n      items = _a.items,\n      columnDefinitions = _a.columnDefinitions,\n      trackBy = _a.trackBy,\n      loading = _a.loading,\n      loadingText = _a.loadingText,\n      selectionType = _a.selectionType,\n      selectedItems = _a.selectedItems,\n      isItemDisabled = _a.isItemDisabled,\n      ariaLabels = _a.ariaLabels,\n      onSelectionChange = _a.onSelectionChange,\n      onSortingChange = _a.onSortingChange,\n      sortingColumn = _a.sortingColumn,\n      sortingDescending = _a.sortingDescending,\n      sortingDisabled = _a.sortingDisabled,\n      visibleColumns = _a.visibleColumns,\n      stickyHeader = _a.stickyHeader,\n      stickyHeaderVerticalOffset = _a.stickyHeaderVerticalOffset,\n      onRowClick = _a.onRowClick,\n      onRowContextMenu = _a.onRowContextMenu,\n      wrapLines = _a.wrapLines,\n      resizableColumns = _a.resizableColumns,\n      onColumnWidthsChange = _a.onColumnWidthsChange,\n      variant = _a.variant,\n      __internalRootRef = _a.__internalRootRef,\n      rest = __rest(_a, [\"header\", \"footer\", \"empty\", \"filter\", \"pagination\", \"preferences\", \"items\", \"columnDefinitions\", \"trackBy\", \"loading\", \"loadingText\", \"selectionType\", \"selectedItems\", \"isItemDisabled\", \"ariaLabels\", \"onSelectionChange\", \"onSortingChange\", \"sortingColumn\", \"sortingDescending\", \"sortingDisabled\", \"visibleColumns\", \"stickyHeader\", \"stickyHeaderVerticalOffset\", \"onRowClick\", \"onRowContextMenu\", \"wrapLines\", \"resizableColumns\", \"onColumnWidthsChange\", \"variant\", \"__internalRootRef\"]);\n\n  var baseProps = getBaseProps(rest);\n  stickyHeader = stickyHeader && supportsStickyPosition();\n\n  var _c = useContainerQuery(function (_a) {\n    var width = _a.width;\n    return width;\n  }),\n      containerWidth = _c[0],\n      wrapperMeasureRef = _c[1];\n\n  var wrapperRefObject = useRef(null);\n  var wrapperRef = useMergeRefs(wrapperMeasureRef, wrapperRefObject);\n\n  var _d = useContainerQuery(function (_a) {\n    var width = _a.width;\n    return width;\n  }),\n      tableWidth = _d[0],\n      tableMeasureRef = _d[1];\n\n  var tableRefObject = useRef(null);\n  var tableRef = useMergeRefs(tableMeasureRef, tableRefObject);\n  var secondaryWrapperRef = React.useRef(null);\n  var theadRef = useRef(null);\n  var stickyHeaderRef = React.useRef(null);\n  var scrollbarRef = React.useRef(null);\n  useImperativeHandle(ref, function () {\n    var _a;\n\n    return {\n      scrollToTop: ((_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop) || function () {\n        return undefined;\n      }\n    };\n  });\n  var handleScroll = useScrollSync([wrapperRefObject, scrollbarRef, secondaryWrapperRef], !supportsStickyPosition());\n\n  var _e = useFocusMove(selectionType, items.length),\n      moveFocusDown = _e.moveFocusDown,\n      moveFocusUp = _e.moveFocusUp,\n      moveFocus = _e.moveFocus;\n\n  var _f = useRowEvents({\n    onRowClick: onRowClick,\n    onRowContextMenu: onRowContextMenu\n  }),\n      onRowClickHandler = _f.onRowClickHandler,\n      onRowContextMenuHandler = _f.onRowContextMenuHandler;\n\n  var visibleColumnDefinitions = visibleColumns ? columnDefinitions.filter(function (column) {\n    return column.id && visibleColumns.indexOf(column.id) !== -1;\n  }) : columnDefinitions;\n\n  var _g = useSelection({\n    items: items,\n    trackBy: trackBy,\n    selectedItems: selectedItems,\n    selectionType: selectionType,\n    isItemDisabled: isItemDisabled,\n    onSelectionChange: onSelectionChange,\n    ariaLabels: ariaLabels\n  }),\n      isItemSelected = _g.isItemSelected,\n      selectAllProps = _g.selectAllProps,\n      getItemSelectionProps = _g.getItemSelectionProps,\n      updateShiftToggle = _g.updateShiftToggle;\n\n  if (loading) {\n    selectAllProps.disabled = true;\n  }\n\n  if (isDevelopment) {\n    if (resizableColumns) {\n      checkColumnWidths(columnDefinitions);\n    }\n\n    if (sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingComparator) {\n      checkSortingState(columnDefinitions, sortingColumn.sortingComparator);\n    }\n  }\n\n  var isRefresh = useVisualRefresh(tableRefObject);\n  var computedVariant = isRefresh ? variant : ['embedded', 'full-page'].indexOf(variant) > -1 ? 'container' : variant;\n  var hasHeader = !!(header || filter || pagination || preferences);\n  var theadProps = {\n    containerWidth: containerWidth,\n    selectionType: selectionType,\n    selectAllProps: selectAllProps,\n    columnDefinitions: visibleColumnDefinitions,\n    variant: computedVariant,\n    wrapLines: wrapLines,\n    resizableColumns: resizableColumns,\n    sortingColumn: sortingColumn,\n    sortingDisabled: sortingDisabled,\n    sortingDescending: sortingDescending,\n    onSortingChange: onSortingChange,\n    onFocusMove: moveFocus,\n    onResizeFinish: function onResizeFinish(newWidth) {\n      var widthsDetail = columnDefinitions.map(function (column, index) {\n        return newWidth[getColumnKey(column, index)] || column.width || DEFAULT_WIDTH;\n      });\n      var widthsChanged = widthsDetail.some(function (width, index) {\n        return columnDefinitions[index].width !== width;\n      });\n\n      if (widthsChanged) {\n        fireNonCancelableEvent(onColumnWidthsChange, {\n          widths: widthsDetail\n        });\n      }\n    }\n  }; // Allows keyboard users to scroll horizontally with arrow keys by making the wrapper part of the tab sequence\n\n  var isWrapperScrollable = tableWidth && containerWidth && tableWidth > containerWidth;\n  var wrapperProps = isWrapperScrollable ? {\n    role: 'region',\n    tabIndex: 0,\n    'aria-label': ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel\n  } : {};\n  var focusVisibleProps = useFocusVisible();\n  return React.createElement(ColumnWidthsProvider, {\n    tableRef: tableRefObject,\n    visibleColumnDefinitions: visibleColumnDefinitions,\n    resizableColumns: resizableColumns,\n    hasSelection: !!selectionType\n  }, React.createElement(InternalContainer, __assign({}, baseProps, {\n    __internalRootRef: __internalRootRef,\n    className: clsx(baseProps.className, styles.root),\n    header: React.createElement(React.Fragment, null, hasHeader && React.createElement(\"div\", {\n      className: clsx(styles['header-controls'], styles[\"variant-\".concat(computedVariant)])\n    }, React.createElement(ToolsHeader, {\n      header: header,\n      filter: filter,\n      pagination: pagination,\n      preferences: preferences\n    })), stickyHeader && React.createElement(StickyHeader, {\n      ref: stickyHeaderRef,\n      variant: computedVariant,\n      theadProps: theadProps,\n      wrapperRef: wrapperRefObject,\n      theadRef: theadRef,\n      secondaryWrapperRef: secondaryWrapperRef,\n      tableRef: tableRefObject,\n      onScroll: handleScroll\n    })),\n    disableHeaderPaddings: true,\n    disableContentPaddings: true,\n    variant: toContainerVariant(computedVariant),\n    __disableFooterPaddings: true,\n    __disableFooterDivider: true,\n    footer: footer && React.createElement(\"div\", {\n      className: clsx(styles['footer-wrapper'], styles[\"variant-\".concat(computedVariant)])\n    }, React.createElement(\"hr\", {\n      className: styles.divider\n    }), React.createElement(\"div\", {\n      className: styles.footer\n    }, footer)),\n    __stickyHeader: stickyHeader,\n    __stickyOffset: stickyHeaderVerticalOffset\n  }, focusMarkers.root), React.createElement(\"div\", __assign({\n    ref: wrapperRef,\n    className: clsx(styles.wrapper, styles[\"variant-\".concat(computedVariant)], (_b = {}, _b[styles['has-footer']] = !!footer, _b[styles['has-header']] = hasHeader, _b)),\n    onScroll: handleScroll\n  }, wrapperProps, focusVisibleProps), React.createElement(\"table\", {\n    ref: tableRef,\n    className: clsx(styles.table, resizableColumns && styles['table-layout-fixed']),\n    // Browsers have weird mechanism to guess whether it's a data table or a layout table.\n    // If we state explicitly, they get it always correctly even with low number of rows.\n    role: \"table\",\n    \"aria-label\": ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel\n  }, React.createElement(Thead, __assign({\n    ref: theadRef,\n    hidden: stickyHeader,\n    onCellFocus: function onCellFocus(colIndex) {\n      var _a;\n\n      return (_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.setFocusedColumn(colIndex);\n    },\n    onCellBlur: function onCellBlur() {\n      var _a;\n\n      return (_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.setFocusedColumn(null);\n    }\n  }, theadProps)), React.createElement(\"tbody\", null, loading || items.length === 0 ? React.createElement(\"tr\", null, React.createElement(\"td\", {\n    colSpan: selectionType ? visibleColumnDefinitions.length + 1 : visibleColumnDefinitions.length,\n    className: styles['cell-merged']\n  }, React.createElement(\"div\", {\n    className: styles['cell-merged-content'],\n    style: {\n      width: supportsStickyPosition() && containerWidth && Math.floor(containerWidth) || undefined\n    }\n  }, loading ? React.createElement(InternalStatusIndicator, {\n    type: \"loading\",\n    className: styles.loading,\n    wrapText: true\n  }, loadingText) : React.createElement(\"div\", {\n    className: styles.empty\n  }, empty)))) : items.map(function (item, rowIndex) {\n    var firstVisible = rowIndex === 0;\n    var lastVisible = rowIndex === items.length - 1;\n    var isSelected = !!selectionType && isItemSelected(item);\n    var isPrevSelected = !!selectionType && !firstVisible && isItemSelected(items[rowIndex - 1]);\n    var isNextSelected = !!selectionType && !lastVisible && isItemSelected(items[rowIndex + 1]);\n    return React.createElement(\"tr\", __assign({\n      key: getItemKey(trackBy, item, rowIndex),\n      className: clsx(styles.row, isSelected && styles['row-selected']),\n      onFocus: function onFocus(_a) {\n        var _b;\n\n        var currentTarget = _a.currentTarget;\n        return (_b = stickyHeaderRef.current) === null || _b === void 0 ? void 0 : _b.scrollToRow(currentTarget);\n      }\n    }, focusMarkers.item, {\n      onClick: onRowClickHandler && onRowClickHandler.bind(null, rowIndex, item),\n      onContextMenu: onRowContextMenuHandler && onRowContextMenuHandler.bind(null, rowIndex, item)\n    }), selectionType !== undefined && React.createElement(TableBodyCell, {\n      className: styles['selection-control'],\n      isFirstRow: firstVisible,\n      isLastRow: lastVisible,\n      isSelected: isSelected,\n      isNextSelected: isNextSelected,\n      isPrevSelected: isPrevSelected,\n      wrapLines: false\n    }, React.createElement(SelectionControl, __assign({\n      onFocusDown: moveFocusDown,\n      onFocusUp: moveFocusUp,\n      onShiftToggle: updateShiftToggle\n    }, getItemSelectionProps(item)))), visibleColumnDefinitions.map(function (column, colIndex) {\n      return React.createElement(TableBodyCellContent, {\n        key: getColumnKey(column, colIndex),\n        style: resizableColumns ? {} : {\n          width: column.width,\n          minWidth: column.minWidth,\n          maxWidth: column.maxWidth\n        },\n        column: column,\n        item: item,\n        wrapLines: wrapLines,\n        isFirstRow: firstVisible,\n        isLastRow: lastVisible,\n        isSelected: isSelected,\n        isNextSelected: isNextSelected,\n        isPrevSelected: isPrevSelected\n      });\n    }));\n  }))), resizableColumns && React.createElement(ResizeTracker, null)), React.createElement(StickyScrollbar, {\n    ref: scrollbarRef,\n    wrapperRef: wrapperRefObject,\n    tableRef: tableRefObject,\n    onScroll: handleScroll\n  })));\n});\nexport default InternalTable;","map":null,"metadata":{},"sourceType":"module"}