{"ast":null,"code":"import { __rest } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport { nodeContains } from '../internal/utils/dom';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { getXTickCount, getYTickCount, createXTicks, createYTicks } from '../internal/components/cartesian-chart/ticks';\nimport ChartPlot from '../internal/components/chart-plot';\nimport AxisLabel from '../internal/components/cartesian-chart/axis-label';\nimport LabelsMeasure from '../internal/components/cartesian-chart/labels-measure';\nimport LeftLabels from '../internal/components/cartesian-chart/left-labels';\nimport BottomLabels from '../internal/components/cartesian-chart/bottom-labels';\nimport VerticalGridLines from '../internal/components/cartesian-chart/vertical-grid-lines';\nimport EmphasizedBaseline from '../internal/components/cartesian-chart/emphasized-baseline';\nimport HighlightedPoint from '../internal/components/cartesian-chart/highlighted-point';\nimport VerticalMarker from '../internal/components/cartesian-chart/vertical-marker';\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport ChartPopover from './chart-popover';\nimport { computeDomainX, computeDomainY } from './utils';\nimport makeScaledSeries from './make-scaled-series';\nimport makeScaledBarGroups from './make-scaled-bar-groups';\nimport formatHighlighted from './format-highlighted';\nimport DataSeries from './data-series';\nimport BarGroups from './bar-groups';\nimport { useMouseHover } from './hooks/use-mouse-hover';\nimport { useNavigation } from './hooks/use-navigation';\nimport { usePopover } from './hooks/use-popover';\nimport styles from './styles.css.js';\nimport useContainerWidth from '../internal/utils/use-container-width';\nimport { useMergeRefs } from '../internal/hooks/use-merge-refs';\nvar LEFT_LABELS_MARGIN = 16;\nvar BOTTOM_LABELS_OFFSET = 12;\nexport default function ChartContainer(_a) {\n  var _b;\n\n  var plotHeight = _a.height,\n      series = _a.series,\n      visibleSeries = _a.visibleSeries,\n      highlightedSeries = _a.highlightedSeries,\n      onHighlightChange = _a.onHighlightChange,\n      highlightedPoint = _a.highlightedPoint,\n      setHighlightedPoint = _a.setHighlightedPoint,\n      highlightedGroupIndex = _a.highlightedGroupIndex,\n      setHighlightedGroupIndex = _a.setHighlightedGroupIndex,\n      legendSeries = _a.legendSeries,\n      _c = _a.detailPopoverSize,\n      detailPopoverSize = _c === void 0 ? 'medium' : _c,\n      _d = _a.stackedBars,\n      stackedBars = _d === void 0 ? false : _d,\n      _e = _a.horizontalBars,\n      horizontalBars = _e === void 0 ? false : _e,\n      xScaleType = _a.xScaleType,\n      yScaleType = _a.yScaleType,\n      xTickFormatter = _a.xTickFormatter,\n      yTickFormatter = _a.yTickFormatter,\n      emphasizeBaselineAxis = _a.emphasizeBaselineAxis,\n      xTitle = _a.xTitle,\n      yTitle = _a.yTitle,\n      ariaLabel = _a.ariaLabel,\n      ariaLabelledby = _a.ariaLabelledby,\n      ariaDescription = _a.ariaDescription,\n      _f = _a.i18nStrings,\n      i18nStrings = _f === void 0 ? {} : _f,\n      plotContainerRef = _a.plotContainerRef,\n      props = __rest(_a, [\"height\", \"series\", \"visibleSeries\", \"highlightedSeries\", \"onHighlightChange\", \"highlightedPoint\", \"setHighlightedPoint\", \"highlightedGroupIndex\", \"setHighlightedGroupIndex\", \"legendSeries\", \"detailPopoverSize\", \"stackedBars\", \"horizontalBars\", \"xScaleType\", \"yScaleType\", \"xTickFormatter\", \"yTickFormatter\", \"emphasizeBaselineAxis\", \"xTitle\", \"yTitle\", \"ariaLabel\", \"ariaLabelledby\", \"ariaDescription\", \"i18nStrings\", \"plotContainerRef\"]);\n\n  var plotRef = useRef(null);\n  var verticalMarkerRef = useRef(null);\n\n  var _g = useState(0),\n      leftLabelsWidth = _g[0],\n      setLeftLabelsWidth = _g[1];\n\n  var _h = useState(0),\n      bottomLabelsHeight = _h[0],\n      setBottomLabelsHeight = _h[1];\n\n  var _j = useContainerWidth(500),\n      containerWidth = _j[0],\n      containerMeasureRef = _j[1];\n\n  var plotWidth = containerWidth ? containerWidth - leftLabelsWidth - LEFT_LABELS_MARGIN : 500;\n  var containerRefObject = useRef(null);\n  var containerRef = useMergeRefs(containerMeasureRef, containerRefObject);\n  var isRefresh = useVisualRefresh(containerRefObject);\n  var linesOnly = series.every(function (_a) {\n    var series = _a.series;\n    return series.type === 'line' || series.type === 'threshold';\n  });\n  var xDomain = props.xDomain || computeDomainX(series, xScaleType);\n  var yDomain = props.yDomain || computeDomainY(series, yScaleType, stackedBars);\n  var xTickCount = getXTickCount(plotWidth);\n  var yTickCount = getYTickCount(plotHeight);\n  var rangeBottomTop = [0, plotHeight];\n  var rangeTopBottom = [plotHeight, 0];\n  var rangeLeftRight = [0, plotWidth];\n  var xScale = new ChartScale(xScaleType, xDomain, horizontalBars ? rangeBottomTop : rangeLeftRight, linesOnly);\n  var yScale = new NumericChartScale(yScaleType, yDomain, horizontalBars ? rangeLeftRight : rangeTopBottom, props.yDomain ? null : yTickCount);\n  var xTicks = createXTicks(xScale, xTickCount);\n  var yTicks = createYTicks(yScale, yTickCount);\n  /**\n   * Interactions\n   */\n\n  var highlightedPointRef = useRef(null);\n  var highlightedGroupRef = useRef(null);\n\n  var _k = useState(false),\n      isPlotFocused = _k[0],\n      setPlotFocused = _k[1]; // Some chart components are rendered against \"x\" or \"y\" axes,\n  // When \"horizontalBars\" is enabled, the axes are inverted.\n\n\n  var x = !horizontalBars ? 'x' : 'y';\n  var y = !horizontalBars ? 'y' : 'x';\n  var xy = {\n    ticks: {\n      x: xTicks,\n      y: yTicks\n    },\n    scale: {\n      x: xScale,\n      y: yScale\n    },\n    tickFormatter: {\n      x: xTickFormatter,\n      y: yTickFormatter\n    },\n    title: {\n      x: xTitle,\n      y: yTitle\n    },\n    ariaRoleDescription: {\n      x: i18nStrings.xAxisAriaRoleDescription,\n      y: i18nStrings.yAxisAriaRoleDescription\n    }\n  };\n  var scaledSeries = makeScaledSeries(visibleSeries, xScale, yScale);\n  var barGroups = makeScaledBarGroups(visibleSeries, xScale, plotWidth, plotHeight, y);\n\n  var _l = usePopover(),\n      isPopoverOpen = _l.isPopoverOpen,\n      isPopoverPinned = _l.isPopoverPinned,\n      showPopover = _l.showPopover,\n      pinPopover = _l.pinPopover,\n      dismissPopover = _l.dismissPopover; // Allows to add a delay between popover is dismissed and handlers are enabled to prevent immediate popover reopening.\n\n\n  var _m = useState(!isPopoverPinned),\n      isHandlersDisabled = _m[0],\n      setHandlersDisabled = _m[1];\n\n  useEffect(function () {\n    if (isPopoverPinned) {\n      setHandlersDisabled(true);\n    } else {\n      var timeoutId_1 = setTimeout(function () {\n        return setHandlersDisabled(false);\n      }, 25);\n      return function () {\n        return clearTimeout(timeoutId_1);\n      };\n    }\n  }, [isPopoverPinned]); // Highlighted point and highlighted series must be in sync.\n  // TODO: refactor the code so that it is not possible to make series and point highlight out of sync.\n\n  var highlightPoint = useCallback(function (point) {\n    setHighlightedGroupIndex(null);\n    setHighlightedPoint(point);\n  }, [setHighlightedPoint, setHighlightedGroupIndex]);\n  var highlightSeries = useCallback(function (series) {\n    if (series !== highlightedSeries) {\n      onHighlightChange(series);\n    }\n  }, [highlightedSeries, onHighlightChange]);\n  var highlightGroup = useCallback(function (groupIndex) {\n    highlightSeries(null);\n    setHighlightedPoint(null);\n    setHighlightedGroupIndex(groupIndex);\n  }, [highlightSeries, setHighlightedPoint, setHighlightedGroupIndex]);\n  var clearHighlightedSeries = useCallback(function () {\n    highlightSeries(null);\n    setHighlightedGroupIndex(null);\n    setHighlightedPoint(null);\n    dismissPopover();\n  }, [dismissPopover, highlightSeries, setHighlightedGroupIndex, setHighlightedPoint]);\n\n  var _o = useNavigation({\n    series: series,\n    visibleSeries: visibleSeries,\n    scaledSeries: scaledSeries,\n    barGroups: barGroups,\n    xScale: xScale,\n    yScale: yScale,\n    highlightedPoint: highlightedPoint,\n    highlightedGroupIndex: highlightedGroupIndex,\n    highlightedSeries: highlightedSeries,\n    legendSeries: legendSeries,\n    isHandlersDisabled: isHandlersDisabled,\n    pinPopover: pinPopover,\n    highlightSeries: highlightSeries,\n    highlightGroup: highlightGroup,\n    highlightPoint: highlightPoint,\n    clearHighlightedSeries: clearHighlightedSeries\n  }),\n      isGroupNavigation = _o.isGroupNavigation,\n      handlers = __rest(_o, [\"isGroupNavigation\"]);\n\n  var _p = useMouseHover({\n    scaledSeries: scaledSeries,\n    barGroups: barGroups,\n    plotRef: plotRef,\n    highlightSeries: highlightSeries,\n    highlightPoint: highlightPoint,\n    highlightGroup: highlightGroup,\n    clearHighlightedSeries: clearHighlightedSeries,\n    isGroupNavigation: isGroupNavigation,\n    isHandlersDisabled: isHandlersDisabled\n  }),\n      onSVGMouseMove = _p.onSVGMouseMove,\n      onSVGMouseOut = _p.onSVGMouseOut,\n      verticalMarkerLeft = _p.verticalMarkerLeft; // There are multiple ways to indicate what X is selected.\n  // TODO: make a uniform verticalMarkerX state to fit all use-cases.\n\n\n  var highlightedX = useMemo(function () {\n    var _a, _b, _c, _d;\n\n    if (highlightedGroupIndex !== null) {\n      return barGroups[highlightedGroupIndex].x;\n    }\n\n    if (verticalMarkerLeft !== null) {\n      for (var _i = 0, scaledSeries_1 = scaledSeries; _i < scaledSeries_1.length; _i++) {\n        var series_1 = scaledSeries_1[_i];\n\n        if (series_1.x === verticalMarkerLeft) {\n          return (_b = (_a = series_1.datum) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : null;\n        }\n      }\n    }\n\n    if (highlightedPoint !== null) {\n      return (_d = (_c = highlightedPoint === null || highlightedPoint === void 0 ? void 0 : highlightedPoint.datum) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : null;\n    }\n\n    return null;\n  }, [highlightedPoint, verticalMarkerLeft, highlightedGroupIndex, scaledSeries, barGroups]);\n\n  var onPopoverDismiss = function onPopoverDismiss(outsideClick) {\n    dismissPopover();\n\n    if (!outsideClick) {\n      // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.\n      setTimeout(function () {\n        var _a, _b;\n\n        if (highlightedPoint || highlightedGroupIndex !== null) {\n          (_a = plotRef.current) === null || _a === void 0 ? void 0 : _a.focusApplication();\n        } else {\n          (_b = plotRef.current) === null || _b === void 0 ? void 0 : _b.focusPlot();\n        }\n      }, 0);\n    }\n  };\n\n  useLayoutEffect(function () {\n    if (highlightedX !== null) {\n      showPopover();\n    }\n  }, [highlightedX, showPopover]);\n\n  var onSVGMouseDown = function onSVGMouseDown() {\n    if (isPopoverOpen) {\n      if (isPopoverPinned) {\n        dismissPopover();\n      } else {\n        pinPopover();\n      }\n    } else {\n      showPopover();\n    }\n  };\n\n  var onSVGFocus = function onSVGFocus(event, trigger) {\n    setPlotFocused(true);\n\n    if (trigger === 'keyboard') {\n      handlers.onFocus();\n    } else {// noop: clicks are handled separately\n    }\n  };\n\n  var onSVGBlur = function onSVGBlur(event) {\n    var _a;\n\n    setPlotFocused(false);\n    var blurTarget = event.relatedTarget || event.target;\n\n    if (blurTarget === null || !(blurTarget instanceof Element) || !nodeContains(containerRefObject.current, blurTarget)) {\n      setHighlightedPoint(null);\n\n      if (!((_a = plotContainerRef === null || plotContainerRef === void 0 ? void 0 : plotContainerRef.current) === null || _a === void 0 ? void 0 : _a.contains(blurTarget))) {\n        clearHighlightedSeries();\n      }\n\n      if (isPopoverOpen && !isPopoverPinned) {\n        dismissPopover();\n      }\n    }\n  };\n\n  var onSVGKeyDown = handlers.onKeyDown;\n  var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var verticalLineX = null;\n\n  if (verticalMarkerLeft !== null) {\n    verticalLineX = verticalMarkerLeft;\n  } else if (isGroupNavigation && highlightedGroupIndex !== null) {\n    var x_1 = (_b = xScale.d3Scale(barGroups[highlightedGroupIndex].x)) !== null && _b !== void 0 ? _b : null;\n\n    if (x_1 !== null) {\n      verticalLineX = xOffset + x_1;\n    }\n  }\n\n  var point = useMemo(function () {\n    return highlightedPoint ? {\n      key: \"\".concat(highlightedPoint.x, \"-\").concat(highlightedPoint.y),\n      x: highlightedPoint.x,\n      y: highlightedPoint.y,\n      color: highlightedPoint.color\n    } : null;\n  }, [highlightedPoint]);\n  var verticalMarkers = useMemo(function () {\n    return verticalLineX !== null ? scaledSeries.filter(function (_a) {\n      var x = _a.x;\n      return x === verticalLineX || isNaN(x);\n    }).map(function (_a, index) {\n      var x = _a.x,\n          y = _a.y,\n          color = _a.color;\n      return {\n        key: \"\".concat(index, \"-\").concat(x, \"-\").concat(y),\n        x: !horizontalBars ? verticalLineX || 0 : y,\n        y: !horizontalBars ? y : verticalLineX || 0,\n        color: color\n      };\n    }) : [];\n  }, [scaledSeries, verticalLineX, horizontalBars]);\n  var popoverTrackRef = isGroupNavigation ? highlightedGroupRef : highlightedPoint ? highlightedPointRef : verticalMarkerRef;\n  var highlightDetails = useMemo(function () {\n    if (highlightedX === null) {\n      return null;\n    } // If there is a highlighted point - only use its corresponding series details.\n\n\n    for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {\n      var series_2 = visibleSeries_1[_i];\n\n      if (series_2.series === (highlightedPoint === null || highlightedPoint === void 0 ? void 0 : highlightedPoint.series)) {\n        return formatHighlighted(highlightedX, [series_2], xTickFormatter);\n      }\n    } // Otherwise - use all series details.\n\n\n    return formatHighlighted(highlightedX, visibleSeries, xTickFormatter);\n  }, [highlightedX, highlightedPoint, visibleSeries, xTickFormatter]);\n  var activeAriaLabel = useMemo(function () {\n    return highlightDetails ? \"\".concat(highlightDetails.position, \", \").concat(highlightDetails.details.map(function (d) {\n      return d.key + ' ' + d.value;\n    }).join(',')) : '';\n  }, [highlightDetails]); // Live region is used when nothing is focused e.g. when hovering.\n\n  var activeLiveRegion = activeAriaLabel && !highlightedPoint && highlightedGroupIndex === null ? activeAriaLabel : '';\n  return React.createElement(\"div\", {\n    className: styles['chart-container'],\n    ref: containerRef\n  }, React.createElement(AxisLabel, {\n    axis: y,\n    position: \"left\",\n    title: xy.title[y]\n  }), React.createElement(\"div\", {\n    className: styles['chart-container__horizontal']\n  }, React.createElement(LabelsMeasure, {\n    ticks: xy.ticks[y],\n    scale: xy.scale[y],\n    tickFormatter: xy.tickFormatter[y],\n    autoWidth: setLeftLabelsWidth\n  }), React.createElement(\"div\", {\n    className: styles['chart-container__vertical']\n  }, React.createElement(ChartPlot, {\n    ref: plotRef,\n    width: plotWidth,\n    height: plotHeight,\n    offsetBottom: bottomLabelsHeight,\n    isClickable: isPopoverOpen && !isPopoverPinned,\n    ariaLabel: ariaLabel,\n    ariaLabelledby: ariaLabelledby,\n    ariaDescription: ariaDescription,\n    ariaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.chartAriaRoleDescription,\n    ariaLiveRegion: activeLiveRegion,\n    activeElementRef: isGroupNavigation ? highlightedGroupRef : highlightedPointRef,\n    activeElementKey: isPlotFocused && ((highlightedGroupIndex === null || highlightedGroupIndex === void 0 ? void 0 : highlightedGroupIndex.toString()) || (point === null || point === void 0 ? void 0 : point.key)),\n    activeElementFocusOffset: isGroupNavigation ? 0 : 3,\n    onMouseMove: onSVGMouseMove,\n    onMouseOut: onSVGMouseOut,\n    onMouseDown: onSVGMouseDown,\n    onFocus: onSVGFocus,\n    onBlur: onSVGBlur,\n    onKeyDown: onSVGKeyDown\n  }, React.createElement(LeftLabels, {\n    axis: y,\n    ticks: xy.ticks[y],\n    scale: xy.scale[y],\n    tickFormatter: xy.tickFormatter[y],\n    title: xy.title[y],\n    ariaRoleDescription: xy.ariaRoleDescription[y],\n    width: plotWidth,\n    height: plotHeight\n  }), horizontalBars && React.createElement(VerticalGridLines, {\n    scale: yScale,\n    ticks: yTicks,\n    height: plotHeight\n  }), emphasizeBaselineAxis && linesOnly && React.createElement(EmphasizedBaseline, {\n    axis: x,\n    scale: yScale,\n    width: plotWidth,\n    height: plotHeight\n  }), React.createElement(DataSeries, {\n    axis: x,\n    plotWidth: plotWidth,\n    plotHeight: plotHeight,\n    highlightedSeries: highlightedSeries !== null && highlightedSeries !== void 0 ? highlightedSeries : null,\n    highlightedGroupIndex: highlightedGroupIndex,\n    stackedBars: stackedBars,\n    isGroupNavigation: isGroupNavigation,\n    visibleSeries: visibleSeries,\n    xScale: xScale,\n    yScale: yScale\n  }), emphasizeBaselineAxis && !linesOnly && React.createElement(EmphasizedBaseline, {\n    axis: x,\n    scale: yScale,\n    width: plotWidth,\n    height: plotHeight\n  }), React.createElement(VerticalMarker, {\n    key: verticalLineX || '',\n    height: plotHeight,\n    showPoints: highlightedPoint === null,\n    showLine: !isGroupNavigation,\n    points: verticalMarkers,\n    ref: verticalMarkerRef\n  }), highlightedPoint && React.createElement(HighlightedPoint, {\n    ref: highlightedPointRef,\n    point: point,\n    role: \"button\",\n    ariaLabel: activeAriaLabel,\n    ariaHasPopup: true,\n    ariaExpanded: isPopoverPinned\n  }), isGroupNavigation && xScale.isCategorical() && React.createElement(BarGroups, {\n    ariaLabel: activeAriaLabel,\n    isRefresh: isRefresh,\n    isPopoverPinned: isPopoverPinned,\n    barGroups: barGroups,\n    highlightedGroupIndex: highlightedGroupIndex,\n    highlightedGroupRef: highlightedGroupRef\n  }), React.createElement(BottomLabels, {\n    axis: x,\n    ticks: xy.ticks[x],\n    scale: xy.scale[x],\n    tickFormatter: xy.tickFormatter[x],\n    title: xy.title[x],\n    ariaRoleDescription: xy.ariaRoleDescription[x],\n    height: plotHeight,\n    width: plotWidth,\n    offsetLeft: leftLabelsWidth + BOTTOM_LABELS_OFFSET,\n    offsetRight: BOTTOM_LABELS_OFFSET,\n    autoHeight: setBottomLabelsHeight\n  })), React.createElement(AxisLabel, {\n    axis: x,\n    position: \"bottom\",\n    title: xy.title[x]\n  })), React.createElement(ChartPopover, {\n    containerRef: containerRefObject,\n    trackRef: popoverTrackRef,\n    isOpen: isPopoverOpen,\n    isPinned: isPopoverPinned,\n    highlightDetails: highlightDetails,\n    onDismiss: onPopoverDismiss,\n    size: detailPopoverSize,\n    dismissAriaLabel: i18nStrings.detailPopoverDismissAriaLabel\n  })));\n}","map":null,"metadata":{},"sourceType":"module"}