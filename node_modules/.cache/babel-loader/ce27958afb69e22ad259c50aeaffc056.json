{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nexport var chartLegendMap = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed'\n};\nexport function computeDomainX(series, xScaleType) {\n  if (xScaleType === 'categorical') {\n    return series.reduce(function (acc, s) {\n      if (s.series.type !== 'threshold') {\n        s.series.data.forEach(function (_a) {\n          var x = _a.x;\n\n          if (acc.indexOf(x) === -1) {\n            acc.push(x);\n          }\n        });\n      }\n\n      return acc;\n    }, []);\n  }\n\n  return series.reduce(function (acc, curr) {\n    if (curr.series.type === 'threshold') {\n      return acc;\n    }\n\n    return curr.series.data.reduce(function (_a, _b) {\n      var min = _a[0],\n          max = _a[1];\n      var x = _b.x;\n      var newMin = min === undefined || x < min ? x : min;\n      var newMax = max === undefined || max < x ? x : max;\n      return [newMin, newMax];\n    }, acc);\n  }, []);\n}\n\nfunction find(arr, func) {\n  for (var i = 0; i < arr.length; i++) {\n    var found = func(arr[i]);\n\n    if (found) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n\nexport function computeDomainY(series, scaleType, stackedBars) {\n  var _series = series; // For stacked bars, we need to accumulate all the bar series into a positive and a negative series\n\n  if (stackedBars) {\n    var _a = series.reduce(function (acc, curr) {\n      if (curr.series.type === 'bar') {\n        curr.series.data.forEach(function (_a) {\n          var x = _a.x,\n              y = _a.y;\n          var data = y < 0 ? acc.negativeData : acc.positiveData;\n          var stackedDatum = find(data, function (el) {\n            return matchesX(el.x, x);\n          });\n\n          if (stackedDatum) {\n            stackedDatum.y += y;\n          } else {\n            data.push({\n              x: x,\n              y: y\n            });\n          }\n\n          return acc;\n        });\n      }\n\n      return acc;\n    }, {\n      positiveData: [],\n      negativeData: []\n    }),\n        positiveData = _a.positiveData,\n        negativeData = _a.negativeData; // Artificial series with the sum of all bars when stacked\n\n\n    var stackedSeries = [{\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'positive',\n        data: positiveData\n      }\n    }, {\n      color: '',\n      index: NaN,\n      series: {\n        type: 'bar',\n        title: 'negative',\n        data: negativeData\n      }\n    }]; // MixedLineBarChart can also contain other non-bar series,\n    // so we replace all bars with the artificial bar series\n    // Then proceed to compute range with it and the remaining (non-bar) series\n\n    _series = __spreadArray(__spreadArray([], stackedSeries, true), _series.filter(function (s) {\n      return s.series.type !== 'bar';\n    }), true);\n  }\n\n  var domain = _series.reduce(function (acc, curr) {\n    if (curr.series.type === 'threshold') {\n      var min = acc[0],\n          max = acc[1];\n      var y = curr.series.y;\n      var newMin = min === undefined || y < min ? y : min;\n      var newMax = max === undefined || max < y ? y : max;\n      return [newMin, newMax];\n    }\n\n    return curr.series.data.reduce(function (_a, _b) {\n      var min = _a[0],\n          max = _a[1];\n      var y = _b.y;\n      var newMin = min === undefined || y < min ? y : min;\n      var newMax = max === undefined || max < y ? y : max;\n      return [newMin, newMax];\n    }, acc);\n  }, [0, 0]); // Log scales can't start from 0, so if possible, start from 1.\n\n\n  if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n    return [1, domain[1]];\n  }\n\n  return domain;\n} // Starting from the given index, find the first x value in the x domain that has bar data attached to it.\n\nexport var nextValidDomainIndex = function nextValidDomainIndex(nextGroupIndex, barGroups, direction) {\n  if (direction === void 0) {\n    direction = 1;\n  }\n\n  var index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n\n    index += direction; // Loop back to the beginning if necessary\n\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n\n  return 0;\n};\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\n\nexport function findNavigableSeries(series) {\n  var navigableSeries = [];\n  var navigableBarSeriesIndex = -1;\n  series.forEach(function (internalSeries) {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return {\n    navigableSeries: navigableSeries,\n    navigableBarSeriesIndex: navigableBarSeriesIndex\n  };\n}\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\n\nexport var matchesX = function matchesX(x1, x2) {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n\n  return x1 === x2;\n};\n/**\n * Calculates list of offset maps from all data by accumulating each value\n */\n\nexport function calculateOffsetMaps(data) {\n  return data.reduce(function (acc, curr, idx) {\n    // First series receives empty offsets map\n    if (idx === 0) {\n      acc.push({\n        positiveOffsets: {},\n        negativeOffsets: {}\n      });\n    }\n\n    var lastMap = acc[idx];\n    var map = lastMap ? {\n      positiveOffsets: __assign({}, lastMap.positiveOffsets),\n      negativeOffsets: __assign({}, lastMap.negativeOffsets)\n    } : {\n      positiveOffsets: {},\n      negativeOffsets: {}\n    };\n    curr.forEach(function (_a) {\n      var x = _a.x,\n          y = _a.y;\n      var key = getKeyValue(x);\n\n      if (y < 0) {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.negativeOffsets[key]) || 0;\n        map.negativeOffsets[key] = lastValue + y;\n      } else {\n        var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.positiveOffsets[key]) || 0;\n        map.positiveOffsets[key] = lastValue + y;\n      }\n    }); // Ignore last value for map but still run it for logging\n\n    if (idx < data.length - 1) {\n      acc.push(map);\n    }\n\n    return acc;\n  }, []);\n}\n/**\n * Returns string or number value for ChartDataTypes key\n */\n\nexport var getKeyValue = function getKeyValue(key) {\n  return key instanceof Date ? key.getTime() : key;\n};","map":null,"metadata":{},"sourceType":"module"}