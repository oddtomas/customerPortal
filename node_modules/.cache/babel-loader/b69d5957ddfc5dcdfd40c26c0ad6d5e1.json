{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { memo, useEffect, useRef } from 'react';\nimport clsx from 'clsx';\nimport { TICK_LENGTH, TICK_LINE_HEIGHT, TICK_MARGIN } from './constants';\nimport styles from './styles.css.js';\nimport { formatTicks, getVisibleTicks } from './label-utils';\nexport default memo(BottomLabels); // Renders the visible tick labels on the bottom axis, as well as their grid lines.\n\nfunction BottomLabels(_a) {\n  var _b = _a.axis,\n      axis = _b === void 0 ? 'x' : _b,\n      width = _a.width,\n      height = _a.height,\n      scale = _a.scale,\n      ticks = _a.ticks,\n      tickFormatter = _a.tickFormatter,\n      title = _a.title,\n      ariaRoleDescription = _a.ariaRoleDescription,\n      autoHeight = _a.autoHeight,\n      _c = _a.offsetLeft,\n      offsetLeft = _c === void 0 ? 0 : _c,\n      _d = _a.offsetRight,\n      offsetRight = _d === void 0 ? 0 : _d;\n  var virtualTextRef = useRef(null);\n  var xOffset = scale.isCategorical() && axis === 'x' ? Math.max(0, scale.d3Scale.bandwidth() - 1) / 2 : 0;\n  var cacheRef = useRef({});\n\n  var getLabelSpace = function getLabelSpace(label) {\n    if (cacheRef.current[label] !== undefined) {\n      return cacheRef.current[label];\n    }\n\n    if (virtualTextRef.current && virtualTextRef.current.getComputedTextLength) {\n      virtualTextRef.current.textContent = label;\n      cacheRef.current[label] = virtualTextRef.current.getComputedTextLength();\n      return cacheRef.current[label];\n    }\n\n    return 0;\n  };\n\n  var formattedTicks = formatTicks({\n    ticks: ticks,\n    scale: scale,\n    getLabelSpace: getLabelSpace,\n    tickFormatter: tickFormatter\n  });\n\n  if (virtualTextRef.current) {\n    virtualTextRef.current.textContent = '';\n  }\n\n  var from = 0 - offsetLeft - xOffset;\n  var until = width + offsetRight - xOffset;\n  var balanceLabels = axis === 'x' && scale.scaleType !== 'log';\n  var visibleTicks = getVisibleTicks(formattedTicks, from, until, balanceLabels);\n  var maxHeight = TICK_LENGTH + TICK_MARGIN;\n\n  for (var _i = 0, formattedTicks_1 = formattedTicks; _i < formattedTicks_1.length; _i++) {\n    var lines = formattedTicks_1[_i].lines;\n    maxHeight = Math.max(maxHeight, TICK_LENGTH + TICK_MARGIN + lines.length * TICK_LINE_HEIGHT);\n  } // Tell elements's height to the parent.\n\n\n  useEffect(function () {\n    autoHeight(maxHeight);\n  }, [autoHeight, maxHeight]);\n  return React.createElement(\"g\", {\n    transform: \"translate(0,\".concat(height, \")\"),\n    className: styles['labels-bottom'],\n    focusable: false,\n    \"aria-label\": title,\n    role: \"list\",\n    \"aria-roledescription\": ariaRoleDescription,\n    \"aria-hidden\": true\n  }, visibleTicks.map(function (_a, index) {\n    var _b;\n\n    var position = _a.position,\n        lines = _a.lines;\n    return isFinite(position) && React.createElement(\"g\", {\n      key: index,\n      transform: \"translate(\".concat(position + xOffset, \",0)\"),\n      className: clsx(styles.ticks, styles['ticks--bottom'], (_b = {}, _b[styles['ticks--x']] = axis === 'x', _b[styles['ticks--y']] = axis === 'y', _b)),\n      role: \"listitem\",\n      \"aria-label\": lines.join('\\n')\n    }, React.createElement(\"line\", {\n      className: styles.ticks__line,\n      x1: 0,\n      x2: 0,\n      y1: 0,\n      y2: TICK_LENGTH,\n      \"aria-hidden\": \"true\"\n    }), lines.map(function (line, lineIndex) {\n      return React.createElement(\"text\", {\n        className: styles.ticks__text,\n        key: lineIndex,\n        x: 0,\n        y: TICK_LENGTH + TICK_MARGIN + lineIndex * TICK_LINE_HEIGHT\n      }, line);\n    }));\n  }), React.createElement(\"text\", {\n    ref: virtualTextRef,\n    x: 0,\n    y: 0,\n    style: {\n      visibility: 'hidden'\n    },\n    \"aria-hidden\": \"true\"\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}