{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver, ResizeObserverEntry } from '@juggle/resize-observer';\nimport { useEffect, useLayoutEffect } from 'react';\nimport { useStableEventHandler } from '../use-stable-event-handler';\n/**\n * Attaches resize-observer to the referenced element.\n *\n * Examples:\n *     // With React reference\n *     const ref = useRef(null)\n *     useResizeObserver(ref, (entry) => setState(getWidth(entry)))\n *\n *     // With ID reference\n *     const getElement = useCallback(() => document.getElementById(id), [id])\n *     useResizeObserver(getElement, (entry) => setState(getWidth(entry)))\n *\n * @param elementRef React reference or memoized getter for the target element\n * @param onObserve Function to fire when observation occurs\n */\n\nexport function useResizeObserver(elementRef, onObserve) {\n  var stableOnObserve = useStableEventHandler(onObserve); // This effect provides a synchronous update required to prevent flakiness when initial state and first observed state are different.\n  // Can potentially conflict with React concurrent mode: https://17.reactjs.org/docs/concurrent-mode-intro.html.\n  // A possible solution would be to make consumers not render any content until the first (asynchronous) observation is available.\n\n  useLayoutEffect(function () {\n    var element = typeof elementRef === 'function' ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n\n    if (element) {\n      onObserve(convertResizeObserverEntry(new ResizeObserverEntry(element)));\n    }\n  }, // This effect is only needed for the first render to provide a synchronous update.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useEffect(function () {\n    var element = typeof elementRef === 'function' ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;\n\n    if (element) {\n      var connected_1 = true;\n      var observer_1 = new ResizeObserver(function (entries) {\n        // Prevent observe notifications on already unmounted component.\n        if (connected_1) {\n          stableOnObserve(convertResizeObserverEntry(entries[0]));\n        }\n      });\n      observer_1.observe(element);\n      return function () {\n        connected_1 = false;\n        observer_1.disconnect();\n      };\n    }\n  }, [elementRef, stableOnObserve]);\n}\n\nfunction convertResizeObserverEntry(entry) {\n  return {\n    target: entry.target,\n    contentBoxWidth: entry.contentBoxSize[0].inlineSize,\n    contentBoxHeight: entry.contentBoxSize[0].blockSize,\n    borderBoxWidth: entry.borderBoxSize[0].inlineSize,\n    borderBoxHeight: entry.borderBoxSize[0].blockSize,\n    width: entry.contentBoxSize[0].inlineSize,\n    height: entry.contentBoxSize[0].blockSize\n  };\n}","map":null,"metadata":{},"sourceType":"module"}