{"ast":null,"code":"var _a, _b, _c;\n\nimport { __spreadArray } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useState } from 'react';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { useUniqueId } from '../internal/hooks/use-unique-id';\nimport { findUpUntil } from '../internal/utils/dom';\nimport { getTrackableValue } from './utils';\nimport selectionStyles from './selection-control/styles.css.js';\nimport { joinStrings } from '../internal/utils/strings';\nvar SELECTION_ITEM = 'selection-item';\nvar SELECTION_ROOT = 'selection-root';\n\nfunction findSelectionControlByIndex(rootContainer, index) {\n  if (index === -1) {\n    // find \"select all\" checkbox\n    return rootContainer.querySelector(\"[data-\".concat(SELECTION_ITEM, \"=\\\"all\\\"] .\").concat(selectionStyles.root, \" input\"));\n  }\n\n  return rootContainer.querySelectorAll(\"[data-\".concat(SELECTION_ITEM, \"=\\\"item\\\"] .\").concat(selectionStyles.root, \" input\"))[index];\n}\n\nfunction findRootContainer(element) {\n  return findUpUntil(element, function (node) {\n    return node.dataset.selectionRoot === 'true';\n  });\n}\n\nexport function useFocusMove(selectionType, totalItems) {\n  if (selectionType !== 'multi') {\n    return {};\n  }\n\n  function moveFocus(sourceElement, fromIndex, direction) {\n    var index = fromIndex;\n    var rootContainer = findRootContainer(sourceElement);\n\n    while (index >= -1 && index < totalItems) {\n      index += direction;\n      var control = findSelectionControlByIndex(rootContainer, index);\n\n      if (control && !control.disabled) {\n        control.focus();\n        break;\n      }\n    }\n  }\n\n  var _a = [1, -1].map(function (direction) {\n    return function (event) {\n      var target = event.currentTarget;\n      var itemNode = findUpUntil(target, function (node) {\n        return node.dataset.selectionItem === 'item';\n      });\n      var fromIndex = Array.prototype.indexOf.call(itemNode.parentElement.children, itemNode);\n      moveFocus(target, fromIndex, direction);\n    };\n  }),\n      moveFocusDown = _a[0],\n      moveFocusUp = _a[1];\n\n  return {\n    moveFocusDown: moveFocusDown,\n    moveFocusUp: moveFocusUp,\n    moveFocus: moveFocus\n  };\n} // A set, that compares items by their \"trackables\" (the results of applying `trackBy` to them)\n\nvar ItemSet =\n/** @class */\nfunction () {\n  function ItemSet(trackBy, items) {\n    var _this = this;\n\n    this.map = new Map();\n\n    this.put = function (item) {\n      return _this.map.set.call(_this.map, getTrackableValue(_this.trackBy, item), item);\n    };\n\n    this.has = function (item) {\n      return _this.map.has.call(_this.map, getTrackableValue(_this.trackBy, item));\n    };\n\n    this.forEach = this.map.forEach.bind(this.map);\n    this.trackBy = trackBy;\n    items.forEach(this.put);\n  }\n\n  return ItemSet;\n}();\n\nexport var focusMarkers = {\n  item: (_a = {}, _a['data-' + SELECTION_ITEM] = 'item', _a),\n  all: (_b = {}, _b['data-' + SELECTION_ITEM] = 'all', _b),\n  root: (_c = {}, _c['data-' + SELECTION_ROOT] = 'true', _c)\n};\nexport function useSelection(_a) {\n  var _b;\n\n  var items = _a.items,\n      _c = _a.selectedItems,\n      selectedItems = _c === void 0 ? [] : _c,\n      selectionType = _a.selectionType,\n      _d = _a.isItemDisabled,\n      isItemDisabled = _d === void 0 ? function () {\n    return false;\n  } : _d,\n      trackBy = _a.trackBy,\n      onSelectionChange = _a.onSelectionChange,\n      ariaLabels = _a.ariaLabels;\n\n  var _e = useState(false),\n      shiftPressed = _e[0],\n      setShiftPressed = _e[1];\n\n  var _f = useState(null),\n      lastClickedItem = _f[0],\n      setLastClickedItem = _f[1];\n\n  var selectionName = useUniqueId();\n  var finalSelectedItems = selectionType === 'single' ? selectedItems.slice(0, 1) : selectedItems;\n  var selectedSet = new ItemSet(trackBy, finalSelectedItems);\n  var itemIndexesMap = new Map();\n  items.forEach(function (item, i) {\n    return itemIndexesMap.set(getTrackableValue(trackBy, item), i);\n  });\n  var isItemSelected = selectedSet.has.bind(selectedSet);\n\n  var getItemState = function getItemState(item) {\n    return {\n      disabled: isItemDisabled(item),\n      selected: isItemSelected(item)\n    };\n  };\n\n  var _g = selectionType ? items.reduce(function (_a, item) {\n    var allDisabled = _a[0],\n        allEnabledSelected = _a[1],\n        hasSelected = _a[2];\n\n    var _b = getItemState(item),\n        disabled = _b.disabled,\n        selected = _b.selected;\n\n    return [// all items are disabled (or none are present)\n    allDisabled && disabled, // all enabled items are selected (or none are present)\n    allEnabledSelected && (selected || disabled), // the page has at least one selected item\n    hasSelected || selected];\n  }, [true, true, false]) : [true, true, false],\n      allDisabled = _g[0],\n      allEnabledSelected = _g[1],\n      hasSelected = _g[2];\n\n  var handleToggleAll = function handleToggleAll() {\n    var requestedItems = new ItemSet(trackBy, items);\n    var newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);\n    fireNonCancelableEvent(onSelectionChange, {\n      selectedItems: newSelectedItems\n    });\n  };\n\n  var getRequestedItems = function getRequestedItems(item) {\n    var requestedItems = new ItemSet(trackBy, [item]);\n    var lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;\n\n    if (lastClickedItemIndex === undefined) {\n      lastClickedItemIndex = -1;\n    } // we use lastClickedItemIndex to determine if filtering/sorting/pagination\n    // made previously selected item invisible, therefore we reset state for shift-select\n\n\n    if (shiftPressed && lastClickedItemIndex !== -1) {\n      // item is always in items\n      var currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));\n      var start = Math.min(currentItemIndex, lastClickedItemIndex);\n      var end = Math.max(currentItemIndex, lastClickedItemIndex);\n      items.slice(start, end + 1).forEach(function (item) {\n        return requestedItems.put(item);\n      });\n    }\n\n    return requestedItems;\n  };\n\n  var deselectItems = function deselectItems(requestedItems) {\n    var newSelectedItems = [];\n    selectedItems.forEach(function (selectedItem) {\n      var toUnselect = requestedItems.has(selectedItem);\n\n      if (!toUnselect || isItemDisabled(selectedItem)) {\n        newSelectedItems.push(selectedItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  var selectItems = function selectItems(requestedItems) {\n    var newSelectedItems = __spreadArray([], selectedItems, true);\n\n    requestedItems.forEach(function (newItem) {\n      var _a = getItemState(newItem),\n          selected = _a.selected,\n          disabled = _a.disabled;\n\n      if (!selected && !disabled) {\n        newSelectedItems.push(newItem);\n      }\n    });\n    return newSelectedItems;\n  };\n\n  var handleToggleItem = function handleToggleItem(item) {\n    return function () {\n      var _a = getItemState(item),\n          disabled = _a.disabled,\n          selected = _a.selected;\n\n      if (disabled || selectionType === 'single' && selected) {\n        return;\n      }\n\n      if (selectionType === 'single') {\n        fireNonCancelableEvent(onSelectionChange, {\n          selectedItems: [item]\n        });\n      } else {\n        var requestedItems = getRequestedItems(item);\n        var selectedItems_1 = selected ? deselectItems(requestedItems) : selectItems(requestedItems);\n        fireNonCancelableEvent(onSelectionChange, {\n          selectedItems: selectedItems_1\n        });\n        setLastClickedItem(item);\n      }\n    };\n  };\n\n  return {\n    isItemSelected: isItemSelected,\n    selectAllProps: {\n      name: selectionName,\n      disabled: allDisabled,\n      selectionType: selectionType,\n      indeterminate: hasSelected && !allEnabledSelected,\n      checked: hasSelected && allEnabledSelected,\n      onChange: handleToggleAll,\n      ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, {\n        selectedItems: selectedItems\n      }))\n    },\n    getItemSelectionProps: function getItemSelectionProps(item) {\n      var _a;\n\n      return {\n        name: selectionName,\n        selectionType: selectionType,\n        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, {\n          selectedItems: selectedItems\n        }, item)),\n        onChange: handleToggleItem(item),\n        checked: isItemSelected(item),\n        disabled: isItemDisabled(item)\n      };\n    },\n    updateShiftToggle: function updateShiftToggle(value) {\n      setShiftPressed(value);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"module"}