{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useMemo, useRef } from 'react';\nimport clsx from 'clsx';\nimport { matchesX, getKeyValue } from './utils';\nimport styles from './styles.css.js';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nexport default function BarSeries(_a) {\n  var _b;\n\n  var axis = _a.axis,\n      series = _a.series,\n      color = _a.color,\n      xScale = _a.xScale,\n      yScale = _a.yScale,\n      highlighted = _a.highlighted,\n      dimmed = _a.dimmed,\n      highlightedGroupIndex = _a.highlightedGroupIndex,\n      stackedBarOffsets = _a.stackedBarOffsets,\n      totalSeriesCount = _a.totalSeriesCount,\n      seriesIndex = _a.seriesIndex,\n      plotSize = _a.plotSize,\n      chartAreaClipPath = _a.chartAreaClipPath;\n  var seriesRef = useRef(null);\n  var isRefresh = useVisualRefresh(seriesRef);\n  var xCoordinates = useMemo(function () {\n    var _a;\n\n    if (series.type !== 'bar' || !xScale.isCategorical()) {\n      return [];\n    }\n\n    var yContinuosScale = yScale.d3Scale;\n    var xPoints = series.data.map(function (_a) {\n      var x = _a.x;\n      return xScale.d3Scale(x) || NaN;\n    });\n    var zeroY = (_a = yScale.d3Scale(0)) !== null && _a !== void 0 ? _a : NaN;\n    var baseY = isFinite(zeroY) ? Math.min(plotSize, zeroY) : plotSize;\n    var barWidth = xScale.d3Scale.bandwidth();\n    var PADDING = 4;\n    var MINWIDTH = 4;\n\n    if (!stackedBarOffsets && totalSeriesCount > 1) {\n      // Regular grouped bars\n      barWidth = (barWidth - (totalSeriesCount - 1) * PADDING) / totalSeriesCount;\n      barWidth = Math.max(barWidth, MINWIDTH);\n    }\n\n    return xPoints.map(function (x, i) {\n      var _a, _b;\n\n      var d = series.data[i];\n      var barX = x;\n      var yValue = d.y;\n\n      if (stackedBarOffsets) {\n        // Stacked bars\n        var offsetMap = d.y < 0 ? stackedBarOffsets.negativeOffsets : stackedBarOffsets.positiveOffsets;\n        yValue = d.y + (offsetMap[getKeyValue(d.x)] || 0);\n      } else if (totalSeriesCount > 1) {\n        // Regular grouped bars\n        barX += seriesIndex * (barWidth + PADDING);\n      } // Account for negative values growing \"down\" instead of \"up\"\n\n\n      yValue = yValue < 0 ? yValue - d.y : yValue;\n      return {\n        x: barX,\n        y: (_a = yContinuosScale(yValue)) !== null && _a !== void 0 ? _a : NaN,\n        width: barWidth,\n        height: Math.abs(((_b = yContinuosScale(d.y)) !== null && _b !== void 0 ? _b : NaN) - baseY)\n      };\n    });\n  }, [series, xScale, yScale, plotSize, stackedBarOffsets, totalSeriesCount, seriesIndex]);\n  var highlightedXValue = highlightedGroupIndex !== null ? xScale.domain[highlightedGroupIndex] : null;\n  return React.createElement(\"g\", {\n    \"aria-label\": series.title,\n    clipPath: \"url(#\".concat(chartAreaClipPath, \")\"),\n    className: clsx(styles.series, styles['series--bar'], (_b = {}, _b[styles['series--highlighted']] = highlighted, _b[styles['series--dimmed']] = dimmed, _b)),\n    ref: seriesRef\n  }, xCoordinates.map(function (_a, i) {\n    var _b;\n\n    var x = _a.x,\n        y = _a.y,\n        width = _a.width,\n        height = _a.height;\n    return isFinite(x) && isFinite(height) && React.createElement(\"rect\", {\n      key: \"bar-\".concat(i),\n      fill: color,\n      x: axis === 'x' ? x : y - height,\n      y: axis === 'x' ? y : x,\n      width: axis === 'x' ? width : height,\n      height: axis === 'x' ? height : width,\n      rx: isRefresh ? '4px' : '0px',\n      className: clsx(styles.series__rect, (_b = {}, _b[styles['series--dimmed']] = highlightedXValue !== null && !matchesX(highlightedXValue, series.data[i].x), _b))\n    });\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}