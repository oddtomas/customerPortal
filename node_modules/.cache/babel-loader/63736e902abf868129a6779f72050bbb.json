{"ast":null,"code":"var ARROW_OFFSET = 12;\nexport var PRIORITY_MAPPING = {\n  top: ['top-center', 'bottom-center', 'right-top', 'right-bottom', 'left-top', 'left-bottom', 'top-right', 'top-left', 'bottom-right', 'bottom-left'],\n  bottom: ['bottom-center', 'top-center', 'right-top', 'right-bottom', 'left-top', 'left-bottom', 'bottom-right', 'bottom-left', 'top-right', 'top-left'],\n  left: ['left-top', 'left-bottom', 'right-top', 'right-bottom', 'bottom-center', 'top-center', 'bottom-left', 'top-left', 'bottom-right', 'top-right'],\n  right: ['right-top', 'right-bottom', 'left-top', 'left-bottom', 'bottom-center', 'top-center', 'bottom-right', 'top-right', 'bottom-left', 'top-left']\n};\nvar RECTANGLE_CALCULATIONS = {\n  'top-center': function topCenter(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'top-right': function topRight(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'top-left': function topLeft(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top - body.height - arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-center': function bottomCenter(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width / 2 - body.width / 2,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-right': function bottomRight(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'bottom-left': function bottomLeft(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height + arrow.height,\n      left: trigger.left + trigger.width - body.width,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'right-top': function rightTop(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'right-bottom': function rightBottom(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left + trigger.width + arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'left-top': function leftTop(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  },\n  'left-bottom': function leftBottom(_a) {\n    var body = _a.body,\n        trigger = _a.trigger,\n        arrow = _a.arrow;\n    return {\n      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,\n      left: trigger.left - body.width - arrow.height,\n      width: body.width,\n      height: body.height\n    };\n  }\n};\n/**\n * Returns whether one rectangle fits in another.\n */\n\nfunction canRectFit(inner, outer) {\n  return inner.left >= outer.left && inner.top >= outer.top && inner.left + inner.width <= outer.left + outer.width && inner.top + inner.height <= outer.top + outer.height;\n}\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\n\n\nexport function intersectRectangles(rectangles) {\n  var boundingOffset = null;\n\n  for (var _i = 0, rectangles_1 = rectangles; _i < rectangles_1.length; _i++) {\n    var currentRect = rectangles_1[_i];\n\n    if (!boundingOffset) {\n      boundingOffset = currentRect;\n      continue;\n    }\n\n    var left = Math.max(boundingOffset.left, currentRect.left);\n    var top_1 = Math.max(boundingOffset.top, currentRect.top);\n    var right = Math.min(boundingOffset.left + boundingOffset.width, currentRect.left + currentRect.width);\n    var bottom = Math.min(boundingOffset.top + boundingOffset.height, currentRect.top + currentRect.height);\n\n    if (right < left || bottom < top_1) {\n      return null;\n    }\n\n    boundingOffset = {\n      left: left,\n      top: top_1,\n      width: right - left,\n      height: bottom - top_1\n    };\n  }\n\n  return boundingOffset && boundingOffset.height * boundingOffset.width;\n}\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\n\nexport function calculatePosition(preferred, trigger, arrow, body, container, viewport, // the popover is only bound by the viewport if it is rendered in a portal\nrenderWithPortal) {\n  var bestPositionOutsideViewport = null;\n  var largestArea = 0; // Attempt to position the popover based on the priority list for this position,\n  // trying to fit it inside the container and inside the viewport.\n\n  for (var _i = 0, _a = PRIORITY_MAPPING[preferred]; _i < _a.length; _i++) {\n    var internalPosition = _a[_i];\n    var boundingOffset = RECTANGLE_CALCULATIONS[internalPosition]({\n      body: body,\n      trigger: trigger,\n      arrow: arrow\n    });\n    var fitsInContainer = renderWithPortal || canRectFit(boundingOffset, container);\n    var fitsInViewport = canRectFit(boundingOffset, viewport);\n\n    if (fitsInContainer && fitsInViewport) {\n      return {\n        internalPosition: internalPosition,\n        boundingOffset: boundingOffset\n      };\n    }\n\n    var boundingRectangles = [boundingOffset, viewport];\n\n    if (!renderWithPortal) {\n      boundingRectangles.push(container);\n    }\n\n    var availableArea = intersectRectangles(boundingRectangles);\n\n    if (availableArea && availableArea > largestArea) {\n      bestPositionOutsideViewport = {\n        internalPosition: internalPosition,\n        boundingOffset: boundingOffset\n      };\n      largestArea = availableArea;\n    }\n  } // Position it in the best position outside the viewport. The user will need to scroll to view\n  // the contents, but at least it's accessible once they do.\n\n\n  if (bestPositionOutsideViewport !== null) {\n    return bestPositionOutsideViewport;\n  } // Resort to right-top\n\n\n  return {\n    internalPosition: 'right-top',\n    boundingOffset: RECTANGLE_CALCULATIONS['right-top']({\n      body: body,\n      trigger: trigger,\n      arrow: arrow\n    })\n  };\n}","map":null,"metadata":{},"sourceType":"module"}