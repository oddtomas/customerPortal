{"ast":null,"code":"import { __assign } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { findNavigableSeries, nextValidDomainIndex } from '../utils';\nexport function useNavigation(_a) {\n  var series = _a.series,\n      visibleSeries = _a.visibleSeries,\n      scaledSeries = _a.scaledSeries,\n      barGroups = _a.barGroups,\n      xScale = _a.xScale,\n      yScale = _a.yScale,\n      highlightedPoint = _a.highlightedPoint,\n      highlightedGroupIndex = _a.highlightedGroupIndex,\n      highlightedSeries = _a.highlightedSeries,\n      legendSeries = _a.legendSeries,\n      isHandlersDisabled = _a.isHandlersDisabled,\n      pinPopover = _a.pinPopover,\n      highlightSeries = _a.highlightSeries,\n      highlightGroup = _a.highlightGroup,\n      highlightPoint = _a.highlightPoint;\n\n  var _b = useState(null),\n      targetX = _b[0],\n      setTargetX = _b[1]; // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n\n\n  var isGroupNavigation = visibleSeries.some(function (_a) {\n    var series = _a.series;\n    return series.type === 'bar';\n  }); // Make a list of series that can be navigated between. Bar series are treated as one.\n\n  var navigableSeries = useMemo(function () {\n    return findNavigableSeries(visibleSeries);\n  }, [visibleSeries]).navigableSeries;\n\n  var onBarGroupFocus = function onBarGroupFocus() {\n    var groupIndex = highlightedGroupIndex !== null && highlightedGroupIndex !== void 0 ? highlightedGroupIndex : 0;\n    setTargetX(xScale.domain[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  var onLineGroupFocus = function onLineGroupFocus() {\n    var _a, _b, _c;\n\n    if (!highlightedSeries || !highlightedPoint) {\n      var targetSeries = (_c = (_a = highlightedSeries !== null && highlightedSeries !== void 0 ? highlightedSeries : legendSeries) !== null && _a !== void 0 ? _a : (_b = series[0]) === null || _b === void 0 ? void 0 : _b.series) !== null && _c !== void 0 ? _c : null;\n      highlightSeries(targetSeries);\n\n      for (var _i = 0, scaledSeries_1 = scaledSeries; _i < scaledSeries_1.length; _i++) {\n        var scaledS = scaledSeries_1[_i];\n\n        if (scaledS.series === targetSeries) {\n          highlightPoint(scaledS);\n          return;\n        }\n      }\n    }\n  };\n\n  var onFocus = function onFocus() {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineGroupFocus();\n    }\n  };\n\n  var moveBetweenSeries = useCallback(function (direction) {\n    var _a, _b, _c;\n\n    if (isGroupNavigation) {\n      return;\n    }\n\n    var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n    var MAX_SERIES_INDEX = navigableSeries.length - 1; // Find the index of the currently highlighted series (if any)\n\n    var previousSeriesIndex = -1;\n\n    if (highlightedSeries) {\n      previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n    } // Move forwards or backwards to the new series\n\n\n    var nextSeriesIndex = 0;\n\n    if (previousSeriesIndex !== -1) {\n      nextSeriesIndex = previousSeriesIndex + direction;\n\n      if (nextSeriesIndex > MAX_SERIES_INDEX) {\n        nextSeriesIndex = 0;\n      } else if (nextSeriesIndex < 0) {\n        nextSeriesIndex = MAX_SERIES_INDEX;\n      }\n    }\n\n    var nextSeries = navigableSeries[nextSeriesIndex];\n    var nextInternalSeries = series.filter(function (_a) {\n      var series = _a.series;\n      return series === nextSeries;\n    })[0]; // 2. Find point in the next series\n\n    var targetXPoint = ((_a = xScale.d3Scale(targetX)) !== null && _a !== void 0 ? _a : NaN) + xOffset;\n\n    if (!isFinite(targetXPoint)) {\n      targetXPoint = 0;\n    }\n\n    if (nextSeries.type === 'line') {\n      var nextSeriesData = nextSeries.data;\n      var lookingForScaled_1 = targetXPoint; // scaled X in previous series\n\n      var nextPoint = nextSeriesData // scale all points in series\n      .map(function (d) {\n        return {\n          x: (xScale.d3Scale(d.x) || 0) + xOffset,\n          y: yScale.d3Scale(d.y) || 0,\n          datum: d\n        };\n      }) // find the closest point to previous X\n      .reduce(function (prev, curr) {\n        return Math.abs(curr.x - lookingForScaled_1) < Math.abs(prev.x - lookingForScaled_1) ? curr : prev;\n      }, {\n        x: -Infinity,\n        y: -Infinity\n      });\n      highlightSeries(nextSeries);\n      highlightPoint(__assign(__assign({}, nextPoint), {\n        color: nextInternalSeries.color,\n        series: nextSeries\n      }));\n    } else if (nextSeries.type === 'threshold') {\n      var scaledTargetIndex = scaledSeries.map(function (it) {\n        var _a;\n\n        return ((_a = it.datum) === null || _a === void 0 ? void 0 : _a.x) || null;\n      }).indexOf(targetX);\n      highlightSeries(nextSeries);\n      highlightPoint({\n        x: targetXPoint,\n        y: (_b = yScale.d3Scale(nextSeries.y)) !== null && _b !== void 0 ? _b : NaN,\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: (_c = scaledSeries[scaledTargetIndex]) === null || _c === void 0 ? void 0 : _c.datum\n      });\n    }\n  }, [isGroupNavigation, xScale, navigableSeries, highlightedSeries, scaledSeries, series, targetX, highlightSeries, highlightPoint, yScale]);\n  var moveWithinSeries = useCallback(function (direction) {\n    var _a;\n\n    var series = highlightedSeries || visibleSeries[0].series;\n    var previousPoint = highlightedPoint || scaledSeries[0];\n\n    if (series.type === 'line') {\n      // find previous point in series\n      var indexOfPreviousPoint = (previousPoint === null || previousPoint === void 0 ? void 0 : previousPoint.datum) ? series.data.indexOf(previousPoint.datum) : 0;\n      var nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, series.data.length - 1]);\n      var nextPoint_1 = series.data[nextPointIndex]; // find scaled next point\n\n      var nextPointScaled = scaledSeries.filter(function (s) {\n        return s.datum === nextPoint_1;\n      })[0] || null;\n      setTargetX(nextPoint_1.x);\n      highlightSeries(series);\n      highlightPoint(nextPointScaled);\n    } else if (series.type === 'threshold') {\n      var scaledThresholdSeries = scaledSeries.filter(function (it) {\n        return it.series === series;\n      })[0];\n      var scaledDataSeries = scaledSeries.filter(function (it) {\n        return it.datum;\n      });\n      var indexOfPreviousPoint = scaledDataSeries.map(function (it) {\n        return it.x;\n      }).indexOf(previousPoint.x);\n      var nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, scaledDataSeries.length - 1]);\n      setTargetX(((_a = scaledDataSeries[nextPointIndex].datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n      highlightSeries(series);\n      highlightPoint(__assign(__assign({}, scaledThresholdSeries), {\n        datum: scaledDataSeries[nextPointIndex].datum,\n        x: scaledDataSeries[nextPointIndex].x\n      }));\n    } else if (series.type === 'bar') {\n      var xDomain = xScale.domain;\n      var MAX_GROUP_INDEX = xDomain.length - 1;\n      var nextGroupIndex = 0;\n\n      if (highlightedGroupIndex !== null) {\n        // find next group\n        nextGroupIndex = highlightedGroupIndex + direction;\n\n        if (nextGroupIndex > MAX_GROUP_INDEX) {\n          nextGroupIndex = 0;\n        } else if (nextGroupIndex < 0) {\n          nextGroupIndex = MAX_GROUP_INDEX;\n        }\n      }\n\n      var nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n      setTargetX(xDomain[nextDomainIndex]);\n      highlightGroup(nextDomainIndex);\n    }\n  }, [highlightedSeries, visibleSeries, highlightedPoint, scaledSeries, highlightSeries, highlightPoint, xScale.domain, highlightedGroupIndex, barGroups, highlightGroup]);\n  var onKeyDown = useCallback(function (event) {\n    var keyCode = event.keyCode;\n\n    if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n      return;\n    }\n\n    event.preventDefault();\n\n    if (isHandlersDisabled) {\n      return;\n    }\n\n    if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n      moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n    } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n      moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);\n    } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n      pinPopover();\n    }\n  }, [moveWithinSeries, moveBetweenSeries, isHandlersDisabled, pinPopover]);\n  return {\n    isGroupNavigation: isGroupNavigation,\n    onFocus: onFocus,\n    onKeyDown: onKeyDown\n  };\n} // Returns given index if it is in range or the opposite range boundary otherwise.\n\nfunction circleIndex(index, _a) {\n  var from = _a[0],\n      to = _a[1];\n\n  if (index < from) {\n    return to;\n  }\n\n  if (index > to) {\n    return from;\n  }\n\n  return index;\n}","map":null,"metadata":{},"sourceType":"module"}