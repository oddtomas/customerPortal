{"ast":null,"code":"import { __assign } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useEffect, useRef, useState } from 'react';\nimport InternalAutosuggest from '../autosuggest/internal';\nimport useFocusVisible from '../internal/hooks/focus-visible';\nimport { KeyCode } from '../internal/keycode';\nimport { makeCancellable, PromiseCancelledSignal } from '../internal/utils/promises';\nimport styles from './styles.css.js';\nexport var TagControl = React.forwardRef(function (_a, ref) {\n  var row = _a.row,\n      value = _a.value,\n      readOnly = _a.readOnly,\n      defaultOptions = _a.defaultOptions,\n      placeholder = _a.placeholder,\n      errorText = _a.errorText,\n      loadingText = _a.loadingText,\n      suggestionText = _a.suggestionText,\n      tooManySuggestionText = _a.tooManySuggestionText,\n      limit = _a.limit,\n      filteringKey = _a.filteringKey,\n      enteredTextLabel = _a.enteredTextLabel,\n      _onChange = _a.onChange,\n      _onBlur = _a.onBlur,\n      onRequest = _a.onRequest,\n      initialOptionsRef = _a.initialOptionsRef;\n\n  var _b = useState(defaultOptions),\n      options = _b[0],\n      setOptions = _b[1];\n\n  var _c = useState(),\n      statusType = _c[0],\n      setStatusType = _c[1];\n\n  var requestCancelFnRef = useRef({\n    cancel: function cancel() {},\n    isCancelled: function isCancelled() {\n      return false;\n    }\n  });\n  var latestFilteringQuery = useRef({\n    key: undefined,\n    value: undefined\n  });\n\n  var isSameQuery = function isSameQuery(key, value) {\n    return latestFilteringQuery.current.key === key && latestFilteringQuery.current.value === value;\n  }; // Cancel any active promises on unmount.\n\n\n  useEffect(function () {\n    return function () {\n      return requestCancelFnRef.current.cancel();\n    };\n  }, []);\n\n  var _onLoadItems = function onLoadItems(filteringText) {\n    if (!onRequest || isSameQuery(filteringKey, filteringText) || requestCancelFnRef.current.isCancelled()) {\n      return;\n    }\n\n    requestCancelFnRef.current.cancel();\n\n    if (filteringText === '' && (initialOptionsRef === null || initialOptionsRef === void 0 ? void 0 : initialOptionsRef.current) && initialOptionsRef.current.length > 0) {\n      // Load in the background, if the value is empty and we already have suggestions.\n      setOptions(initialOptionsRef.current);\n    }\n\n    if (latestFilteringQuery.current.key !== filteringKey) {\n      setOptions([]);\n    }\n\n    setStatusType('loading');\n    latestFilteringQuery.current = {\n      key: filteringKey,\n      value: filteringText\n    };\n\n    var _a = makeCancellable(onRequest(filteringText)),\n        promise = _a.promise,\n        cancel = _a.cancel,\n        isCancelled = _a.isCancelled;\n\n    promise.then(function (newValues) {\n      var newOptions = newValues.map(function (value) {\n        return {\n          value: value\n        };\n      });\n      setStatusType(undefined);\n      setOptions(newOptions);\n\n      if (initialOptionsRef) {\n        initialOptionsRef.current = newOptions;\n      }\n    })[\"catch\"](function (err) {\n      if (!(err instanceof PromiseCancelledSignal)) {\n        setStatusType('error');\n      }\n    });\n    requestCancelFnRef.current = {\n      cancel: cancel,\n      isCancelled: isCancelled\n    };\n  };\n\n  return React.createElement(InternalAutosuggest, {\n    ref: ref,\n    value: value,\n    readOnly: readOnly,\n    statusType: statusType,\n    options: options.length < limit ? options : [],\n    empty: options.length < limit ? suggestionText : tooManySuggestionText,\n    placeholder: placeholder,\n    errorText: errorText,\n    loadingText: loadingText,\n    enteredTextLabel: enteredTextLabel,\n    onChange: function onChange(_a) {\n      var detail = _a.detail;\n      return _onChange(detail.value, row);\n    },\n    onBlur: function onBlur() {\n      return _onBlur === null || _onBlur === void 0 ? void 0 : _onBlur(row);\n    },\n    onFocus: function onFocus() {\n      _onLoadItems('');\n    },\n    onLoadItems: function onLoadItems(_a) {\n      var detail = _a.detail;\n\n      _onLoadItems(detail.filteringText);\n    }\n  });\n});\nexport var UndoButton = React.forwardRef(function (_a, ref) {\n  var children = _a.children,\n      onClick = _a.onClick;\n  var focusVisible = useFocusVisible();\n  return React.createElement(\"a\", __assign({}, focusVisible, {\n    ref: ref,\n    role: \"button\",\n    tabIndex: 0,\n    className: styles['undo-button'],\n    onClick: onClick,\n    onKeyDown: function onKeyDown(event) {\n      if (event.keyCode === KeyCode.space || event.keyCode === KeyCode.enter) {\n        event.preventDefault();\n      } // Enter activates the button on key down instead of key up.\n\n\n      if (event.keyCode === KeyCode.enter) {\n        onClick();\n      }\n    },\n    onKeyUp: function onKeyUp(event) {\n      // Emulate button behavior, which also fires on space.\n      if (event.keyCode === KeyCode.space) {\n        onClick();\n      }\n    }\n  }), children);\n});","map":null,"metadata":{},"sourceType":"module"}