{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { padLeftZeros, insertAt } from './strings';\n\nvar MaskFormat =\n/** @class */\nfunction () {\n  function MaskFormat(_a) {\n    var separator = _a.separator,\n        _b = _a.inputSeparators,\n        inputSeparators = _b === void 0 ? [] : _b,\n        segments = _a.segments;\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n    this.inputSeparators = __spreadArray(__spreadArray([], inputSeparators, true), [separator], false);\n    this.enrichSegmentDefinitions(segments);\n  }\n\n  MaskFormat.prototype.tryAppendSeparator = function (value) {\n    var withSeparator = \"\".concat(value).concat(this.separator);\n    return this.isValid(withSeparator) ? withSeparator : value;\n  };\n\n  MaskFormat.prototype.isSeparator = function (key) {\n    return this.inputSeparators.indexOf(key) !== -1;\n  };\n\n  MaskFormat.prototype.isValid = function (value) {\n    var _this = this;\n\n    var inputSegments = value.split(this.separator);\n\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n\n    return inputSegments.every(function (segmentValue, i) {\n      var segment = _this.segments[i]; // disallow empty segments\n\n      if (segmentValue === '') {\n        // except empty last segment (e.g. trailing separator \"12:\")\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      } // only allow numerals\n\n\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      } // disallow incomplete segments, except at end\n\n\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      } // limit numerical value\n\n\n      var intValue = parseInt(segmentValue, 10); // Handles values padded with 0s that are lost during parsing\n\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        // allow incomplete segments in final position\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    });\n  };\n\n  MaskFormat.prototype.getValidValue = function (value) {\n    var validValue = value;\n\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n\n    return '';\n  };\n\n  MaskFormat.prototype.autoComplete = function (value) {\n    // aka [...completeSegments, lastSegment] = value.split(':')\n    // but that's not valid :/\n    var _a = value.split(this.separator).reverse(),\n        lastSegmentValue = _a[0],\n        completeSegmentValues = _a.slice(1);\n\n    var lastSegment = this.segments[completeSegmentValues.length]; // if the last segment isn't complete, pad it with a preceding 0\n    // e.g. 10:1 -> 10:01\n\n    var paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment); // recombine, and pad with extra segments for the full format\n\n    var partial = __spreadArray(__spreadArray([], completeSegmentValues.reverse(), true), [paddedLastSegmentValue], false);\n\n    while (partial.length < this.segments.length) {\n      var nextSegment = this.segments[partial.length];\n      var segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  };\n\n  MaskFormat.prototype.getSegmentValueWithAddition = function (position, value, enteredDigit) {\n    var segment = this.positionFormats[position];\n    var segmentValue = value.substr(segment.start, segment.length);\n    var segmentPosition = position - segment.start;\n    var newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  };\n\n  MaskFormat.prototype.replaceDigitsWithZeroes = function (value, cursorStart, cursorEnd) {\n    var position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart; // move selection forwards if it starts with a separator\n\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    } // first, insert zeros in a partial segment at beginning of selection\n\n\n    if (!this.isSegmentStart(cursorStart)) {\n      var segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    } // then loop through remaining segments, filling with zeros\n\n\n    var currentSegment;\n\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      var insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(value, padLeftZeros('', insertionEnd - currentSegment.start), currentSegment.start, insertionEnd);\n      cursorStart = insertionEnd + 1;\n    }\n\n    value = this.correctMinMaxValues(value);\n    return {\n      value: value,\n      position: position\n    };\n  };\n\n  MaskFormat.prototype.handleSeparatorInput = function (value, position) {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      var segment = this.positionFormats[position];\n      var segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value: value,\n        position: value.length\n      };\n    }\n  };\n\n  MaskFormat.prototype.isCursorAtSeparator = function (position) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  };\n\n  MaskFormat.prototype.isSegmentStart = function (position) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  };\n\n  MaskFormat.prototype.getSegmentMaxValue = function (value, position) {\n    return this.positionFormats[position].max(value);\n  };\n\n  MaskFormat.prototype.getSegmentMinValue = function (value, position) {\n    return this.positionFormats[position].min;\n  };\n\n  MaskFormat.prototype.getMaxLength = function () {\n    var last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  };\n\n  MaskFormat.prototype.deleteSeparator = function (value, position) {\n    value = insertAt(value, '0', position - 2, position - 1);\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2\n    };\n  };\n\n  MaskFormat.prototype.deleteDigit = function (value, position) {\n    value = insertAt(value, '0', position - 1, position); // 23:59|: => backspace => 23:5|\n\n    var length = value.length;\n\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1\n    };\n  };\n\n  MaskFormat.prototype.correctMinMaxValues = function (value) {\n    var segment = this.positionFormats[0];\n\n    while (segment && value.length >= segment.end) {\n      var segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      var segmentMax = segment.max(value);\n\n      if (segmentValue < segment.min) {\n        var toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n\n      segment = this.positionFormats[segment.end + 1];\n    }\n\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  };\n\n  MaskFormat.prototype.formatPastedText = function (text, value, cursorStart, cursorEnd) {\n    var keyArr = text.trim().split('');\n    var position = cursorStart;\n    var formattedValue = value; // if a selection range captures the end of the current value\n    // we replace it with the value in buffer even if the value in buffer is shorter\n\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n\n    for (var _i = 0, keyArr_1 = keyArr; _i < keyArr_1.length; _i++) {\n      var key = keyArr_1[_i];\n\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n\n      var result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n\n    return this.tryAppendSeparator(formattedValue);\n  };\n\n  MaskFormat.prototype.processKey = function (initialValue, key, initialPosition) {\n    var value = initialValue;\n    var position = initialPosition;\n\n    if (this.isSeparator(key)) {\n      var result = this.handleSeparatorInput(value, position);\n\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      var isCursorAtEnd = position === value.length;\n      var segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      var segmentMaxValue = this.getSegmentMaxValue(value, position);\n      var segmentMinValue = this.getSegmentMinValue(value, position);\n      var firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      var isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      var exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n\n      if (exceedsMaxAtSegmentStart) {\n        // 22:| => Enter '9' => 22:09|\n        // |1 => Enter '9' => 09|\n        value = insertAt(value, \"0\".concat(key), position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        // 22:|22 => Enter '9' => 22:59|\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        // 2|2:22 => Enter '9' => 23:|22\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        // 0| => enter '0' => 01:\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        // 22:| => Enter '5' => 23:5|\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n\n    value = this.tryAppendSeparator(value); // Move cursor in front of separator if behind after overwriting a character\n\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n\n    return {\n      value: value,\n      position: position\n    };\n  };\n\n  MaskFormat.prototype.padWithDefaultValue = function (segmentValue, segment) {\n    var defaultValue = (segment[\"default\"] || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  };\n\n  MaskFormat.prototype.enrichSegmentDefinitions = function (segments) {\n    this.positionFormats = {};\n    this.segments = [];\n    var position = 0;\n\n    var _loop_1 = function _loop_1(segment) {\n      var max = segment.max;\n\n      var fullSegment = __assign(__assign({}, segment), {\n        max: typeof max === 'number' ? function () {\n          return max;\n        } : max,\n        start: position,\n        end: position + segment.length\n      });\n\n      this_1.segments.push(fullSegment); // insert this format segment for every char in the max value\n\n      for (var j = 0; j < fullSegment.length; j++) {\n        this_1.positionFormats[position++] = fullSegment;\n      } // skip a position for separator\n\n\n      position++;\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n      var segment = segments_1[_i];\n\n      _loop_1(segment);\n    }\n  };\n\n  return MaskFormat;\n}();\n\nexport default MaskFormat;","map":null,"metadata":{},"sourceType":"module"}