{"ast":null,"code":"import { __assign, __rest } from \"tslib\"; // Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { createContext, createRef, useCallback, useEffect, useLayoutEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { getSplitPanelPosition } from './split-panel';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useContainerQuery, useResizeObserver } from '../../internal/hooks/container-queries';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport styles from './styles.css.js';\nimport { isDevelopment } from '../../internal/is-development';\nimport { warnOnce } from '../../internal/logging';\nimport { applyDefaults } from '../defaults'; // TODO simplify default params + typings\n\nvar defaults = {\n  breadcrumbs: null,\n  content: null,\n  contentHeader: null,\n  contentType: 'default',\n  disableBodyScroll: false,\n  disableContentHeaderOverlap: false,\n  disableContentPaddings: false,\n  dynamicOverlapHeight: 0,\n  headerHeight: 0,\n  footerHeight: 0,\n  handleNavigationClick: function handleNavigationClick(value) {\n    return value;\n  },\n  handleSplitPanelClick: function handleSplitPanelClick() {},\n  handleSplitPanelPreferencesChange: function handleSplitPanelPreferencesChange() {},\n  handleSplitPanelResize: function handleSplitPanelResize() {},\n  handleToolsClick: function handleToolsClick(value) {\n    return value;\n  },\n  hasDefaultToolsWidth: true,\n  hasNotificationsContent: false,\n  isAnyPanelOpen: false,\n  isMobile: false,\n  isNavigationOpen: false,\n  isSplitPanelForcedPosition: false,\n  isSplitPanelOpen: false,\n  isToolsOpen: false,\n  // TODO: these refs are currently only instantiated once globally\n  layoutElement: createRef(),\n  layoutWidth: 0,\n  mainElement: createRef(),\n  mainOffsetLeft: 0,\n  maxContentWidth: 0,\n  minContentWidth: 280,\n  navigation: null,\n  navigationHide: false,\n  navigationOpen: false,\n  notifications: null,\n  notificationsElement: createRef(),\n  notificationsHeight: 0,\n  offsetBottom: 0,\n  onNavigationChange: function onNavigationChange() {},\n  onSplitPanelResize: function onSplitPanelResize() {},\n  onSplitPanelToggle: function onSplitPanelToggle() {},\n  onSplitPanelPreferencesChange: function onSplitPanelPreferencesChange() {},\n  setDynamicOverlapHeight: function setDynamicOverlapHeight(value) {\n    return void value;\n  },\n  setIsNavigationOpen: function setIsNavigationOpen(value) {\n    return value;\n  },\n  setIsToolsOpen: function setIsToolsOpen(value) {\n    return value;\n  },\n  setOffsetBottom: function setOffsetBottom(value) {\n    return void value;\n  },\n  setSplitPanelReportedSize: function setSplitPanelReportedSize(value) {\n    return void value;\n  },\n  splitPanelMaxWidth: 280,\n  splitPanelMinWidth: 280,\n  splitPanelOpen: false,\n  splitPanelPosition: 'bottom',\n  splitPanelPreferences: {\n    position: 'bottom'\n  },\n  splitPanelReportedSize: 0,\n  splitPanelSize: 0,\n  stickyNotifications: false,\n  tools: null\n};\n/**\n * The default values are destructured in the context instantiation to\n * prevent downstream Typescript errors. This could likely be replaced\n * by a context interface definition that extends the AppLayout interface.\n */\n\nexport var AppLayoutContext = createContext(__assign({}, defaults));\nexport var AppLayoutProvider = React.forwardRef(function (_a, forwardRef) {\n  var _b, _c, _d;\n\n  var toolsHide = _a.toolsHide,\n      controlledToolsOpen = _a.toolsOpen,\n      navigationHide = _a.navigationHide,\n      controlledNavigationOpen = _a.navigationOpen,\n      _e = _a.contentType,\n      contentType = _e === void 0 ? 'default' : _e,\n      _f = _a.headerSelector,\n      headerSelector = _f === void 0 ? '#b #h' : _f,\n      _g = _a.footerSelector,\n      footerSelector = _g === void 0 ? '#b #h' : _g,\n      children = _a.children,\n      props = __rest(_a, [\"toolsHide\", \"toolsOpen\", \"navigationHide\", \"navigationOpen\", \"contentType\", \"headerSelector\", \"footerSelector\", \"children\"]);\n\n  var isMobile = useMobile();\n\n  if (isDevelopment) {\n    if (controlledToolsOpen && toolsHide) {\n      warnOnce('AppLayout', \"You have enabled both the `toolsOpen` prop and the `toolsHide` prop. This is not supported. Set `toolsOpen` to `false` when you set `toolsHide` to `true`.\");\n    }\n  }\n  /**\n   * The overlap height has a default set in CSS but can also be dynamically overridden\n   * for content types (such as Table and Wizard) that have variable size content in the overlap.\n   */\n\n\n  var _h = useState(0),\n      dynamicOverlapHeight = _h[0],\n      setDynamicOverlapHeight = _h[1];\n  /**\n   * Set the default values for minimum and maximum content width.\n   */\n\n\n  var geckoMaxCssLength = ((1 << 30) - 1) / 60;\n  var halfGeckoMaxCssLength = geckoMaxCssLength / 2; // CSS lengths in Gecko are limited to at most (1<<30)-1 app units (Gecko uses 60 as app unit).\n  // Limit the maxContentWidth to the half of the upper boundary (â‰ˆ4230^2) to be on the safe side.\n\n  var maxContentWidth = props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength ? halfGeckoMaxCssLength : (_b = props.maxContentWidth) !== null && _b !== void 0 ? _b : 0;\n  var minContentWidth = (_c = props.minContentWidth) !== null && _c !== void 0 ? _c : 280;\n  /**\n   * Determine the default state of the Navigation and Tools drawers.\n   * Mobile viewports should be closed by default under all circumstances.\n   * If the navigationOpen prop has been set then that should take precedence\n   * over the contentType prop. Desktop viewports that do not have the\n   * navigationOpen or contentType props set will use the default contentType.\n   */\n\n  var contentTypeDefaults = applyDefaults(contentType, {\n    maxContentWidth: maxContentWidth,\n    minContentWidth: minContentWidth\n  }, true);\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Navigation drawer. The logic\n   * for determining the default state is colocated with the Navigation component.\n   *\n   * The callback that will be passed to the Navigation and AppBar\n   * components to handle the click events that will change the state\n   * of the Navigation drawer. It will set the Navigation state with the\n   * useControllable hook and also fire the onNavigationChange function to\n   * emit the state change.\n   */\n\n  var _j = useControllable(controlledNavigationOpen, props.onNavigationChange, isMobile ? false : contentTypeDefaults.navigationOpen, {\n    componentName: 'AppLayout',\n    controlledProp: 'navigationOpen',\n    changeHandler: 'onNavigationChange'\n  }),\n      _k = _j[0],\n      isNavigationOpen = _k === void 0 ? false : _k,\n      setIsNavigationOpen = _j[1];\n\n  var handleNavigationClick = useCallback(function handleNavigationChange(isOpen) {\n    setIsNavigationOpen(isOpen);\n    fireNonCancelableEvent(props.onNavigationChange, {\n      open: isOpen\n    });\n  }, [props.onNavigationChange, setIsNavigationOpen]);\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Tools drawer. The logic\n   * for determining the default state is colocated with the Tools component.\n   *\n   * The callback that will be passed to the Navigation and AppBar\n   * components to handle the click events that will change the state\n   * of the Tools drawer. It will set the Tools state with the\n   * useControllable hook and also fire the onToolsChange function to\n   * emit the state change.\n   */\n\n  var toolsWidth = (_d = props.toolsWidth) !== null && _d !== void 0 ? _d : 290;\n  var hasDefaultToolsWidth = props.toolsWidth === undefined;\n\n  var _l = useControllable(controlledToolsOpen, props.onToolsChange, isMobile ? false : contentTypeDefaults.toolsOpen, {\n    componentName: 'AppLayout',\n    controlledProp: 'toolsOpen',\n    changeHandler: 'onToolsChange'\n  }),\n      _m = _l[0],\n      isToolsOpen = _m === void 0 ? false : _m,\n      setIsToolsOpen = _l[1];\n\n  var handleToolsClick = useCallback(function handleToolsChange(isOpen) {\n    setIsToolsOpen(isOpen);\n    fireNonCancelableEvent(props.onToolsChange, {\n      open: isOpen\n    });\n  }, [props.onToolsChange, setIsToolsOpen]);\n  var navigationVisible = !navigationHide && isNavigationOpen;\n  var toolsVisible = !toolsHide && isToolsOpen;\n  var isAnyPanelOpen = navigationVisible || toolsVisible;\n  /**\n   * On mobile viewports the navigation and tools drawers are adjusted to a fixed position\n   * that consumes 100% of the viewport height and width. The body content could potentially\n   * be scrollable underneath the drawer. In order to prevent this a CSS class needs to be\n   * added to the document body that sets overflow to hidden.\n   */\n\n  useEffect(function handleBodyScroll() {\n    if (isMobile && (isNavigationOpen || isToolsOpen)) {\n      document.body.classList.add(styles['block-body-scroll']);\n    } else {\n      document.body.classList.remove(styles['block-body-scroll']);\n    } // Ensure the CSS class is removed from the body on side effect cleanup\n\n\n    return function cleanup() {\n      document.body.classList.remove(styles['block-body-scroll']);\n    };\n  }, [isMobile, isNavigationOpen, isToolsOpen]);\n  /**\n   * The useImperativeHandle hook in conjunction with the forwardRef function\n   * in the AppLayout component definition expose the following callable\n   * functions to component consumers when they put a ref as a property on\n   * their component implementation.\n   */\n\n  useImperativeHandle(forwardRef, function createImperativeHandle() {\n    return {\n      closeNavigationIfNecessary: function closeNavigationIfNecessary() {\n        isMobile && handleNavigationClick(false);\n      },\n      openTools: function openTools() {\n        handleToolsClick(true);\n      }\n    };\n  }, [isMobile, handleNavigationClick, handleToolsClick]);\n  /**\n   * Query the DOM for the header and footer elements based on the selectors provided\n   * by the properties and pass the heights to the custom property definitions.\n   */\n\n  var _o = useState(0),\n      headerHeight = _o[0],\n      setHeaderHeight = _o[1];\n\n  var getHeader = useCallback(function () {\n    return document.querySelector(headerSelector);\n  }, [headerSelector]);\n  useResizeObserver(getHeader, function (entry) {\n    return setHeaderHeight(entry.borderBoxHeight);\n  });\n\n  var _p = useState(0),\n      footerHeight = _p[0],\n      setFooterHeight = _p[1];\n\n  var getFooter = useCallback(function () {\n    return document.querySelector(footerSelector);\n  }, [footerSelector]);\n  useResizeObserver(getFooter, function (entry) {\n    return setFooterHeight(entry.borderBoxHeight);\n  });\n  /**\n   * Set the default values for the minimum and maximum Split Panel width when it is\n   * in the side position. The useLayoutEffect will compute the available space in the\n   * DOM for the Split Panel given the current state. The minimum and maximum\n   * widths will potentially trigger a side effect that will put the Split Panel into\n   * a forced position on the bottom.\n   */\n\n  var splitPanelMinWidth = 280;\n\n  var _q = useState(splitPanelMinWidth),\n      splitPanelMaxWidth = _q[0],\n      setSplitPanelMaxWidth = _q[1];\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Split Panel. By default\n   * the Split Panel should always be closed on page load.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the click events that will change the state of the SplitPanel\n   * to open or closed given the current state. It will set the isSplitPanelOpen\n   * controlled state and fire the onSplitPanelToggle event.\n   */\n\n\n  var _r = useControllable(props.splitPanelOpen, props.onSplitPanelToggle, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelOpen',\n    changeHandler: 'onSplitPanelToggle'\n  }),\n      isSplitPanelOpen = _r[0],\n      setIsSplitPanelOpen = _r[1];\n\n  var handleSplitPanelClick = useCallback(function handleSplitPanelChange() {\n    setIsSplitPanelOpen(!isSplitPanelOpen);\n    fireNonCancelableEvent(props.onSplitPanelToggle, {\n      open: !isSplitPanelOpen\n    });\n  }, [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen]);\n  /**\n   * The useControllable hook will manage the controlled or uncontrolled\n   * state of the splitPanelPreferences. By default the splitPanelPreferences\n   * is undefined. When set the object shape should have a single key to indicate\n   * either bottom or side position.\n   *\n   * The callback that will handle changes to the splitPanelPreferences\n   * object that will determine if the SplitPanel is rendered either on the\n   * bottom of the viewport or within the Tools container.\n   */\n\n  var _s = useControllable(props.splitPanelPreferences, props.onSplitPanelPreferencesChange, undefined, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelPreferences',\n    changeHandler: 'onSplitPanelPreferencesChange'\n  }),\n      splitPanelPreferences = _s[0],\n      setSplitPanelPreferences = _s[1];\n  /**\n   * The Split Panel will be in forced (bottom) position if the defined minimum width is\n   * greater than the maximum width. In other words, the maximum width is the currently\n   * available horizontal space based on all other components that are rendered. If the\n   * minimum width exceeds this value then there is not enough horizontal space and we must\n   * force it to the bottom position.\n   */\n\n\n  var _t = useState(false),\n      isSplitPanelForcedPosition = _t[0],\n      setSplitPanelForcedPosition = _t[1];\n\n  var splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);\n  useLayoutEffect(function handleSplitPanelForcePosition() {\n    setSplitPanelForcedPosition(splitPanelMinWidth > splitPanelMaxWidth);\n  }, [splitPanelMaxWidth, splitPanelMinWidth]);\n  /**\n   * The useControllable hook will set the default size of the SplitPanel based\n   * on the default position set in the splitPanelPreferences. The logic for the\n   * default size is contained in the SplitPanel component. The splitPanelControlledSize\n   * will be bound to the size property in the SplitPanel context for rendering.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the resize events that will change the size of the SplitPanel.\n   * It will set the splitPanelControlledSize controlled state and fire the\n   * onSplitPanelResize event.\n   */\n\n  var _u = useState(0),\n      splitPanelReportedSize = _u[0],\n      setSplitPanelReportedSize = _u[1];\n\n  var _v = useControllable(props.splitPanelSize, props.onSplitPanelResize, getSplitPanelDefaultSize(splitPanelPosition), {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelSize',\n    changeHandler: 'onSplitPanelResize'\n  }),\n      splitPanelSize = _v[0],\n      setSplitPanelSize = _v[1];\n\n  var handleSplitPanelResize = useCallback(function handleSplitPanelChange(detail) {\n    setSplitPanelSize(detail.size);\n    fireNonCancelableEvent(props.onSplitPanelResize, detail);\n  }, [props.onSplitPanelResize, setSplitPanelSize]);\n  var handleSplitPanelPreferencesChange = useCallback(function handleSplitPanelChange(detail) {\n    setSplitPanelPreferences(detail);\n    fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);\n  }, [props.onSplitPanelPreferencesChange, setSplitPanelPreferences]);\n  /**\n   * The Layout element is not necessarily synonymous with the client\n   * viewport width. There can be content in the horizontal viewport\n   * that exists on either side of the AppLayout. This resize observer\n   * will set the custom property of the Layout element width that\n   * is used for various horizontal constraints such as the maximum\n   * allowed width of the Tools container.\n   *\n   * The offsetLeft of the Main will return the distance that the\n   * Main element has from the left edge of the Layout component.\n   * The offsetLeft value can vary based on the presence and state\n   * of the Navigation as well as content gaps in the grid definition.\n   * This value is used to determine the max width constraint calculation\n   * for the Tools container.\n   */\n\n  var _w = useContainerQuery(function (rect) {\n    return rect.width;\n  }),\n      layoutContainerQuery = _w[0],\n      layoutElement = _w[1];\n\n  var layoutWidth = layoutContainerQuery !== null && layoutContainerQuery !== void 0 ? layoutContainerQuery : 0;\n  var mainElement = useRef(null);\n\n  var _x = useState(0),\n      mainOffsetLeft = _x[0],\n      setMainOffsetLeft = _x[1];\n\n  useLayoutEffect(function handleMainOffsetLeft() {\n    var _a, _b;\n\n    setMainOffsetLeft((_b = (_a = mainElement === null || mainElement === void 0 ? void 0 : mainElement.current) === null || _a === void 0 ? void 0 : _a.offsetLeft) !== null && _b !== void 0 ? _b : 0);\n  }, [layoutWidth, isNavigationOpen, isToolsOpen, splitPanelReportedSize]);\n  useLayoutEffect(function handleSplitPanelMaxWidth() {\n    /**\n     * Warning! This is a hack! In order to accurately calculate if there is adequate\n     * horizontal space for the Split Panel to be in the side position we need two values\n     * that are not available in JavaScript.\n     *\n     * The first is the the content gap on the right which is stored in a design token\n     * and applied in the Layout CSS:\n     *\n     *  $contentGapRight: #{awsui.$space-scaled-2x-xxxl};\n     *\n     * The second is the width of the element that has the circular buttons for the\n     * Tools and Split Panel. This could be suppressed given the state of the Tools\n     * drawer returning a zero value. It would, however, be rendered if the Split Panel\n     * were to move into the side position. This is calculated in the Tools CSS and\n     * the Trigger button CSS with design tokens:\n     *\n     * padding: awsui.$space-scaled-s awsui.$space-layout-toggle-padding;\n     * width: awsui.$space-layout-toggle-diameter;\n     *\n     * These values will be defined below as static integers that are rough approximations\n     * of their computed width when rendered in the DOM, but doubled to ensure adequate\n     * spacing for the Split Panel to be in side position.\n     */\n    var contentGapRight = 80; // Approximately 40px when rendered but doubled for safety\n\n    var toolsFormOffsetWidth = 160; // Approximately 80px when rendered but doubled for safety\n\n    var toolsOffsetWidth = isToolsOpen ? toolsWidth : 0;\n    setSplitPanelMaxWidth(layoutWidth - mainOffsetLeft - minContentWidth - contentGapRight - toolsOffsetWidth - toolsFormOffsetWidth);\n  }, [isNavigationOpen, isToolsOpen, layoutWidth, mainOffsetLeft, minContentWidth, toolsWidth]);\n  /**\n   * Because the notifications slot does not give us any direction insight into\n   * what the state of the child content is we need to have a mechanism for\n   * tracking the height of the notifications and whether or not it has content.\n   * The height of the notifications is an integer that will be used as a custom\n   * property on the Layout component to determine what the sticky offset should\n   * be if there are sticky notifications. This could be any number including\n   * zero based on how the child content renders. The hasNotificationsContent boolean\n   * is simply centralizing the logic of the notifications height being > 0 such\n   * that it is not repeated in various components (such as AppBar) that need to\n   * know if the notifications slot is empty.\n   */\n\n  var _y = useContainerQuery(function (rect) {\n    return rect.height;\n  }),\n      notificationsContainerQuery = _y[0],\n      notificationsElement = _y[1];\n\n  var _z = useState(0),\n      notificationsHeight = _z[0],\n      setNotificationsHeight = _z[1];\n\n  var _0 = useState(false),\n      hasNotificationsContent = _0[0],\n      setHasNotificationsContent = _0[1];\n\n  useEffect(function handleNotificationsContent() {\n    setNotificationsHeight(notificationsContainerQuery !== null && notificationsContainerQuery !== void 0 ? notificationsContainerQuery : 0);\n    setHasNotificationsContent(notificationsContainerQuery && notificationsContainerQuery > 0 ? true : false);\n  }, [notificationsContainerQuery]);\n  /**\n   * The offsetBottom value is used to determine the distance from the bottom of the\n   * viewport a sticky element should be placed. A non-zero value means that there\n   * is either a footer outside of the AppLayout, a SplitPanel in the bottom position\n   * within the AppLayout, or both.\n   */\n\n  var _1 = useState(0),\n      offsetBottom = _1[0],\n      setOffsetBottom = _1[1];\n\n  return React.createElement(AppLayoutContext.Provider, {\n    value: __assign(__assign(__assign({}, defaults), props), {\n      contentType: contentType,\n      dynamicOverlapHeight: dynamicOverlapHeight,\n      headerHeight: headerHeight,\n      footerHeight: footerHeight,\n      hasDefaultToolsWidth: hasDefaultToolsWidth,\n      handleNavigationClick: handleNavigationClick,\n      handleSplitPanelClick: handleSplitPanelClick,\n      handleSplitPanelPreferencesChange: handleSplitPanelPreferencesChange,\n      handleSplitPanelResize: handleSplitPanelResize,\n      handleToolsClick: handleToolsClick,\n      hasNotificationsContent: hasNotificationsContent,\n      isAnyPanelOpen: isAnyPanelOpen,\n      isMobile: isMobile,\n      isNavigationOpen: isNavigationOpen !== null && isNavigationOpen !== void 0 ? isNavigationOpen : false,\n      isSplitPanelForcedPosition: isSplitPanelForcedPosition,\n      isSplitPanelOpen: isSplitPanelOpen,\n      isToolsOpen: isToolsOpen,\n      layoutElement: layoutElement,\n      layoutWidth: layoutWidth,\n      mainElement: mainElement,\n      mainOffsetLeft: mainOffsetLeft,\n      maxContentWidth: maxContentWidth,\n      minContentWidth: minContentWidth,\n      navigationHide: navigationHide,\n      notificationsElement: notificationsElement,\n      notificationsHeight: notificationsHeight,\n      offsetBottom: offsetBottom,\n      setDynamicOverlapHeight: setDynamicOverlapHeight,\n      setOffsetBottom: setOffsetBottom,\n      setSplitPanelReportedSize: setSplitPanelReportedSize,\n      splitPanelMaxWidth: splitPanelMaxWidth,\n      splitPanelMinWidth: splitPanelMinWidth,\n      splitPanelPosition: splitPanelPosition,\n      splitPanelPreferences: splitPanelPreferences,\n      splitPanelReportedSize: splitPanelReportedSize,\n      splitPanelSize: splitPanelSize,\n      toolsHide: toolsHide,\n      toolsOpen: isToolsOpen,\n      toolsWidth: toolsWidth\n    })\n  }, children);\n});","map":null,"metadata":{},"sourceType":"module"}